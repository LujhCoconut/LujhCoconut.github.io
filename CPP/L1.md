# Markdown 1

## 防御性编程与模板类

在 C++ 中，**模板类**（Template Class）是一种可以根据类型参数生成类的机制。它允许我们编写与类型无关的代码，**在编译时指定类型**，从而使得同一个类可以处理不同的数据类型。模板类使得 C++ 可以实现更通用、灵活和可复用的代码。

### **模板类的基本概念**

模板类允许你在定义类时不指定类型，而是使用 **占位符** 来表示类型。然后，在实例化这个类时，传入具体的类型。

#### **定义模板类的语法**

模板类的定义通常以 `template` 关键字开头，后跟一个或多个类型参数。例如：

```c++
template <typename T>  // 'T' 是一个类型参数
class MyClass {
private:
    T value;  // 使用 'T' 类型的成员变量

public:
    MyClass(T val) : value(val) {}  // 构造函数
    T getValue() const { return value; }  // 返回 'T' 类型的值
};
```

> 在上面的代码中，`T` 是一个类型参数（也可以称为类型占位符），它可以在实例化类时被任何类型替代（如 `int`、`double`、`std::string` 等）。

#### **实例化模板类**

一旦定义了模板类，就可以在程序中创建特定类型的对象。这叫做 **实例化模板**。实例化时，编译器会根据传入的类型来生成类的代码：

```c++
MyClass<int> obj1(5);    // 创建一个 'int' 类型的 MyClass 实例
MyClass<double> obj2(3.14);  // 创建一个 'double' 类型的 MyClass 实例
MyClass<std::string> obj3("Hello, World!");  // 创建一个 'std::string' 类型的 MyClass 实例
```

### **模板类的优势**

1. **类型独立性**：模板类的一个显著优势是可以在不重复代码的情况下支持多种数据类型。你可以编写一个通用的模板类，然后在多个地方为不同的数据类型提供实例。
   - 比如，你可以使用模板类来实现一个容器类，容器可以存储任意类型的数据：`int`、`double`、`std::string` 等。
2. **代码复用**：通过模板类，你只需要写一次类的实现，之后可以在不同的上下文中使用不同的类型。
   - 例如，写一个 `Vector` 类模板，它可以用来存储任何类型的数据，而不必为每种类型编写不同的类。
3. **类型安全**：模板类在编译时确定类型，这比使用 `void*` 或其他通用类型来处理不同数据类型更加安全，因为它会在编译时检查类型一致性。
4. **性能优化**：模板类通常是 **编译时生成的**，因此其生成的代码通常是 **高效的**，并且不需要像动态类型那样进行额外的运行时类型检查。模板类可以减少运行时开销。

### **模板类的例子：标准库中的 std::vector**

C++ 标准库中的 `std::vector` 就是一个非常常见的模板类，它可以存储任意类型的元素。比如：

```c++
#include <vector>

std::vector<int> intVec;       // 存储 int 类型的 vector
std::vector<double> doubleVec; // 存储 double 类型的 vector
std::vector<std::string> strVec; // 存储 std::string 类型的 vector
```

### **模板类的复杂性与特性**

1. **多个模板参数**： 模板类可以接受多个类型参数。例如：

   ```c++
   template <typename T, typename U>
   class Pair {
   private:
       T first;
       U second;
   
   public:
       Pair(T f, U s) : first(f), second(s) {}
       T getFirst() { return first; }
       U getSecond() { return second; }
   };
   
   Pair<int, double> p(1, 3.14);  // 使用 int 和 double 作为模板参数
   ```

2. **默认模板参数**： 模板类也可以为类型参数提供默认值，这样在实例化时如果没有传入类型参数，编译器会使用默认类型：

   ```c++
   template <typename T = int>
   class MyClass {
   private:
       T value;
   
   public:
       MyClass(T val) : value(val) {}
       T getValue() { return value; }
   };
   
   MyClass<> obj1(10);  // 使用默认的 int 类型
   MyClass<double> obj2(3.14);  // 使用 double 类型
   ```

3. **模板特化**： 模板类也支持 **模板特化**，即为特定类型提供不同的实现。例如：

   ```c++
   template <typename T>
   class MyClass {
   public:
       void print() { std::cout << "Generic version\n"; }
   };
   
   // 针对 int 类型的特化版本
   template <>
   class MyClass<int> {
   public:
       void print() { std::cout << "Specialized version for int\n"; }
   };
   
   MyClass<float> obj1; // 调用通用版本
   MyClass<int> obj2;   // 调用特化版本
   ```