# C++ 内存管理

## **内存布局**

### 堆

堆是程序运行时动态分配的内存区域，由程序员**显式管理**（手动申请/释放）。它的本质是一块**无序的、可扩展的**内存池，操作系统通过`brk/sbrk`或`mmap`系统调用为其分配虚拟内存。

* **存放什么数据？**

  * **动态创建的对象**：通过`new/malloc`手动分配的资源

    ```c
    int* heapInt = new int(42);       // 整型
    std::string* heapStr = new std::string("Hello"); // 对象
    ```

  * **需要长期存活的数据**：超出函数生命周期仍需使用的数据

    ```c
    // 返回的数组在函数结束后依然有效
    int* createArray(int size) {
        return new int[size]; 
    }
    ```

  * **大块内存**：如大型数组、图像数据等（栈空间通常有限）

* **堆的特点**

  * **手动管理**：必须显式释放（`delete/free`），否则内存泄漏
  * **全局可访问**：只要持有指针，任何函数都可操作堆内存
  * **分配速度慢**：需通过系统调用分配，可能引发缺页中断
  * **碎片化风险**：频繁分配释放不同大小内存会产生碎片
  * **向高地址增长**



### 栈

栈是线程独有的**自动管理**的内存区域，用于支持函数调用。它按照**后进先出（LIFO）**原则工作，每个函数调用会压入一个栈帧（Stack Frame），存储该函数的局部数据。

* **存放什么数据？**

  * **局部变量**：函数内定义的自动变量

    ```c
    void foo() {
        int x = 10;           // 栈变量
        std::string s = "Hi"; // 对象也在栈上（自动调用构造/析构）
    }
    ```

  * **函数参数**：调用时传递的实参

    ```c
    void bar(int param) { /* param在栈上 */ }
    ```

  * **返回地址**：函数调用结束后应返回的位置

  * **寄存器备份**：保存调用前的寄存器状态

* **栈的特点**

  * **自动管理**：进入函数时分配，退出时自动释放
  * **速度快**：只需移动栈指针（ESP/RSP寄存器）
  * **大小受限**：默认约8MB（Linux可通过`ulimit -s`查看）
  * **局部性**：只能被当前函数或子函数访问
  * **向低地址增长**（通过移动栈指针`RSP`实现）



### 堆栈QA

* **请解释为什么递归深度过大会导致栈溢出，而堆分配一般不会出现此问题？**
  * 栈大小固定（通常8MB），每个函数调用压入栈帧（返回地址、局部变量等），递归过深耗尽栈空间。堆大小受虚拟内存限制（TB级），仅受物理内存+交换空间限制。



### 代码区

* **存放内容：**

  * 编译后的**机器指令**（二进制代码）
  * **只读数据**（如字符串常量、`constexpr`变量）

* **特点：**

  * **只读**（修改会导致`Segmentation fault`）

    * 代码区的只读特性是由**操作系统内存保护机制**和**CPU页表权限位**共同实现的。现代CPU的MMU（内存管理单元）会检查页表中的读写权限位，阻止非法写入。

    * 编译器将代码区标记为`r-xp`（可读/执行，不可写）

    * ELF文件头部有`PT_LOAD`段描述权限：

      * ```shell
        readelf -l ./a.out | grep -A1 LOAD
        ```

      * ```shell
        LOAD           0x000000 0x0000555555554000 0x0000555555554000
                       0x0005a4 0x0005a4  R E    0x1000  # R=Read, E=Execute
        ```

  * **固定大小**（编译时确定）

    * ```shell
      size ./a.out
      ```

    * **动态扩展的例外情况**：

      * **动态链接库**：在运行时加载的`.so`/`.dll`文件
      * **JIT编译**：如Java HotSpot、V8引擎生成的代码但传统C++静态编译的程序代码区大小固定。

  * **共享性**（多个进程可共享相同的代码段）

    * ```
      进程A的虚拟地址空间     物理内存      进程B的虚拟地址空间
      +----------------+     +------+     +----------------+
      | 0x55...:       |     |      |     | 0x55...:       |
      |  代码区        |---->| 代码 |<----|  代码区        |
      +----------------+     +------+     +----------------+
      ```

    * **技术实现关键**：

      * **写时复制（COW）**：即使"相同"的代码页，若某进程尝试修改（如调试器插入断点），

        OS会为该进程创建私有副本，不影响其他进程。

      * **内存映射文件**：可执行文件本身被映射到内存，多个进程共享同一磁盘文件。

  > 追问：为什么多个进程可以共享相同的代码段？这会影响进程独立性吗？
  >
  > 回答：共享代码段的实现依赖于两个关键技术：（i）**虚拟内存机制** (ii) **内存映射文件**。 **虚拟内存机制**：每个进程有自己的页表，即使虚拟地址相同（如`0x55...`）也会映射到同一物理页，通过`COW`机制保证修改独立性；**内存映射文件**：将磁盘上的可执行文件直接映射到内存，减少加载开销。这种共享不会破坏进程隔离性，因为：（1）代码段是只读的，无法被进程修改； （2）数据段和堆栈仍是独立的； （3） 若需修改代码（如调试），OS会通过COW创建私有副本。



* 为什么代码段（.text）通常被设计为只读？这样设计有什么安全性和性能上的好处
  * 只读设计提供：① **安全性**：防止代码被恶意篡改（如病毒注入）；② **稳定性**：避免程序自我修改导致不可预测行为；③ **共享性**：多个进程可共享同一物理代码页；④ **性能**：允许更激进的CPU缓存和预测优化。



### 数据区

#### **已初始化数据段（.data）**

* **存放内容：**

  * 显式初始化的**全局变量**和**静态变量**

    ```c
    int global_init = 42;          // 全局变量
    static int static_init = 100;  // 静态变量
    ```

* **特点**

  * 占用**可执行文件空间**（磁盘上有实际数据）
  * 具有**读写权限**



#### 未初始化数据段（.bss）

* **存放内容：**

  * 未显式初始化的全局/静态变量（编译器自动置零）

    ```c
    int global_uninit;             // BSS段
    static int static_uninit;      // BSS段
    ```

* **特点**

  * **不占用磁盘空间**（ELF文件中仅记录大小）
  * 程序加载时由OS初始化为零



#### .bss & .data

* **请解释 `.bss`段和 `.data`段的本质区别，为什么 `.bss`段不占用磁盘空间**
  * `.data`段存储显式初始化的全局/静态变量，这些初始值需要存储在磁盘上的可执行文件中。而 `.bss`段存储未初始化或零初始化的变量，ELF文件只需记录其大小，程序加载时由操作系统分配并初始化为零，因此不占用磁盘空间。



### COW与内存共享

* 请解释Copy-on-Write在内存共享中的具体实现机制

  * COW通过页表权限位实现：

    * 共享的物理页标记为只读；

    * 当进程尝试写入时，触发页错误（page fault）；

      * 类型为`PF_WRITE`（x86错误码bit 1=1）

      * 保存现场：将错误地址存入CR2寄存器，压入错误码和返回地址

      * 跳转到内核预定义的缺页处理程序（`do_page_fault`）

        > CR2 = 发生缺页的虚拟地址
        >
        > RSP = 异常栈指针 
        >
        > RIP = 下一条指令地址

    * 内核捕获错误，复制物理页到新位置；

    * 更新页表指向新页，并设置为可写；

    * 恢复进程执行。这样实现了延迟复制，节省内存。



* 如何观察COW的行为

  * 使用strace观察

    ```shell
    # 输入
    strace -e trace=mmap,pagefault ./cow_program
    
    # 输出
    mmap(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7f8a5e3b6000
    pagefault(0x7f8a5e3b6000, PROT_WRITE) = 0  # 第一次写触发COW
    ```

  * **通过`/proc`接口监控**

    ```shell
    # 输入
    watch -n 1 'cat /proc/vmstat | grep cow'
    
    # 输出
    pgcopypage 1250    # COW发生的次数
    ```

    



* 请详细解释COW过程中内核如何知道要复制哪个页？
  * 内核通过缺页异常的完整上下文确定COW操作:
    * **硬件层面**：CPU将触发异常的虚拟地址存入CR2寄存器，错误类型（写操作）通过错误码传递
    * **地址解析**：内核用CR2的值找到对应的`vm_area_struct`，确认该区域允许写入；
    * **页表检查**：检查PTE的写权限位和脏位，发现是共享的只读页；
    * **物理页定位**：通过PTE中的物理页号找到对应的`page`结构体；
    * **反向映射**：必要时通过`rmap`系统确认所有共享该物理页的进程。



* 为什么写入私有只读页必须触发COW，而不能直接报错或允许写入？
  * 这是由硬件架构和操作系统设计的双重约束决定的：
    * **硬件层面**：CPU的MMU会严格检查页表项的R/W位，任何违规写操作都会触发缺页异常，这是不可绕过的硬件保护；
    * **语义约定**：MAP_PRIVATE的语义要求写入不影响其他共享者，只有COW能同时满足'允许写入'和'隔离修改'这两个矛盾需求；
    * **安全设计**：若允许直接写入共享物理页，会破坏进程隔离性，导致安全漏洞（如修改其他进程的代码段）。



### GDB调试内存布局

* 如何使用Core Dump分析内存布局问题？ 

```shell
gdb ./program core
(gdb) info proc mappings  # 查看内存区域
(gdb) x/32x 0x7ffd...    # 检查栈内容
(gdb) p &variable        # 检查变量地址   
```

深入分析这个部分

**1. 加载Core Dump文件**

```shell
gdb ./your_program /var/crash/core.1234  # 加载可执行文件和core文件
```

此时GDB会显示崩溃时的指令指针位置（RIP/EIP）和信号类型（如SIGSEGV）



**2.查看崩溃上下文**

```shell
(gdb) bt full  # 显示完整调用栈（含局部变量值）
```

示例输出：

```shell
#0  0x00005555555551a9 in crash_function () at test.c:10
   x = 42
   ptr = 0x0
#1  0x00005555555551d2 in main () at test.c:20
   arg = 100
```



**3.检查进程内存映射（关键步骤）**

```shell
(gdb) info proc mappings
```

