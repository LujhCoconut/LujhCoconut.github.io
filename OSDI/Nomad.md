# Nomad(OSDI'24)

【Title】Nomad: Non-Exclusive Memory Tiering via Transactional Page Migration

【定语描述】a new page management mechanism for Linux that features transactional page migration and page shadowing



## Abstract

随着字节寻址内存设备的出现，如CXL内存、PM和存储级内存，分层内存系统已经成为现实。

页面迁移是操作系统中管理分层内存的事实标准方法。它的目标是在尽可能的情况下将“热点”数据移入快速内存，以优化数据访问性能，同时使用慢速内存来存储从快速内存溢出的数据。

尽管现有研究已经证明了各种页面迁移优化方法的有效性，但它并未解决一个根本性问题：**页面要么在快速内存，要么在慢速内存中，而不能同时存在于两者的这种“独占”内存分层策略**，

> 这是否是分层内存管理的最优策略？本文就探讨了这个问题

本文展示了**基于页面迁移的独占内存分层在快速内存面临压力时会导致显著的性能下降**。于是本文就提出了一种**非独占（Non-exclusive）内存分层**策略，这种策略在页面从慢速内存提升到快速内存时保留页面副本，以缓解内存抖动现象从而解决上述问题。

**NOMAD**是一个面向Linux的新页面管理机制，具有事务性页面迁移和Page Shadowing的特点。Nomad将页面迁移从程序执行的关键路径中移除，并使迁移完全异步化。文章声称**NOMAD在内存压力下能够实现相对于Linux中最先进的透明页面放置（TPP）方法高达6倍的性能提升**。



## Introduction

随着新型内存设备的不断出现，例如高带宽内存（HBM）、DRAM、持久性内存、基于CXL的内存 以及存储级内存，未来的计算机系统预计将拥有具有不同特性的多层次内存，例如速度、容量、功耗和成本。**分层内存管理旨在利用每一层内存的优势，优化整体的数据访问延迟和带宽**。分层内存管理的**核心是在操作系统（OS）中进行页面管理**，包括页面的**分配、放置和迁移**。操作系统中高效的页面管理对于在优化内存利用率和性能的同时保持对用户应用程序的透明性至关重要。

传统的异构内存（在过去几十年吧），不同内存介质的性能相差挺大的，至少一个数量级。所以基本上只需要考虑将Hot Page放在Performance Tier，Cold Page Evict到Capacity Tier，保证Performance Tier Hit Ratio尽可能高。

但现在其实不同层级的内存介质性能可能就差几倍，在一个数量级上。现在只考虑热度，页面迁移带来的性能提升是不是真的能够平衡迁移代价并带来可观的收益呢？答案很可能已经不是了。

**像Intel PM或者现在的CXL设备，都可以通过load/store访问。那像不是很热的温页面就没有必要在迁移来迁移去的，甚至就让它丢在Capacity Tier可能也是个好的选择。** 由于内存介质毕竟硬件特性不同，所以其性能还是会存在差异，但是对于CPU来说，既然都能load/store，那确实都可以抽象成同样的内存节点。

那肯定有一堆工作想去优化这种新的异构内存结构。大部分关注的还是页面迁移的准确率、速度等等。

这里面提到了几个工作（没写过的笔记后续会补上）：

* Nimble ： 透明大页，多线程迁移，并发迁移
* TPP : 扩展了Linux的NUMA Balancing，提升Fast Memory和Slow Memory的异步页面降级和同步页面升级
* Memtis  & TMTS：利用硬件性能计数器（比如PEBS）减少基于Page的操作，比如Trace页面，然后启用后台线程异步提升页面

作者认为，这些工作存在两个根本的限制：

* 页面在不同内存介质里是互斥的，或者说只能独占一种内存介质
  * 分层内存收益的场景基本上都有比较大的工作集，但比较大的工作集很可能比performance tier的容量还大。那就有可能Hot Page大小performance tier的容量还大，这就会造成过多的冷热交换和页面抖动。
* 页面迁移的代价挺高的（类似于minor page fault），现有的策略不太高效
  * 这包含了三个步骤：（1）页表里unmap页面  （2）copy 页面到其它tier （3）remap这个页面，使其指向新地址
  * 不管同步异步，这个代价都不低
  * 且在页面迁移时候，这个页面相当于被锁住，无法被访问；一旦频繁发生，会使用户感知的带宽显著低于峰值带宽



NOMAD提出非独占内存分层，允许性能层中的一部分页面在容量层上拥有**影子副本**。

需要注意的是，**非独占分层不同于包含性分层，后者严格将性能层用作容量层的缓存**。最重要的好处是，在内存压力下，如果页面未被修改且其影子副本存在于容量层上，则页面降级变得更加经济，只需重新映射该页面。这使得当内存需求超过性能层容量时，性能过渡更加平滑。

为了降低页面迁移的成本，特别是在提升时，本文提出了**事务性页面迁移（TPM）**，这是一种新机制，可以在迁移期间启用页面访问。**与当前的页面迁移不同，TPM 在不解除容量层页面映射的情况下开始复制页面内容，因此迁移的页面仍然可以被用户程序访问。在页面内容复制到性能层的新页面后，TPM 检查在迁移过程中页面是否被修改。如果被修改，则页面迁移（即事务）将被作废，复制的页面将被丢弃。**失败的页面迁移将在稍后时间重试。如果成功，复制的新页面将被映射到页表中，旧页面将被解除映射，成为新页面的影子副本。

> 感觉想法很直接啊，没什么特别的，之前真没人做过？vTMM是不是就是这么干的（没印象了）？



NOMAD，这是一个新的页面管理框架，旨在支持分层内存，结合了非独占内存分层和事务性页面迁移。**NOMAD 通过防止因page shadowing复制而导致的内存不足（OOM）错误来保障页面分配**。当容量层面临内存压力时，NOMAD 优先回收影子页面，然后再逐出普通页面。我们在 Linux 中实现了 NOMAD 的原型，并在四个平台上进行了全面评估，包括基于 FPGA 的 CXL 原型、持久性内存系统和一款尚未上市的商业 CXL 系统。实验结果表明，与两种代表性的页面管理方案（TPP 和 Memtis）相比，NOMAD 在内存抖动期间的性能提升最高可达 6 倍，并且在工作集大小适合快速内存的情况下，NOMAD 的性能持续超过 Memtis，提升幅度高达 130%。

> 这实验感觉也是挑软柿子捏，挑薄弱处狠狠进攻？



## Motivation & Related Work



### 内存分层和SOTA页面迁移机制

这是一个非常熟悉的概念，主要是包括将不同的内存介质分成performance tier和capacity tier。具体的这段请参见memstrata笔记。

为了充分发挥异构内存的性能，一些经典的算法比如冷热识别的方式会采取各种方式来进行识别。相关的简介也已经多次提及，主要就是扫page table的操作和像Intel PEBS这种硬件层级的操作。

具体请参见memstrata的`Background & Detailed Information`

这里着重介绍一下论文里面提到的`Linux` `Lazy PT`机制：主要是简单地维护了两个LRU队列，简单来说就是一个冷数据队列和一个热数据队列。所有新分配的页面都会首先进入`inactive list`也就是冷队列，然后根据访问等等设置对应的状态位，以此来指导页面的升级（即进入热队列）。值得注意的是对于匿名页面，需要在`memory reclaiming`的时候，再修改对应的状态位。

TPP是ASPLOS'23年的工作，它优化了这个`Linux PT Scanning`.所有的页面将会首先分配到slow memory (e.g. CXL-based Memory)。当TPP决定是否要对页面进行升级，会引入一个`minor page fault`,查看该页面是否位于`active list`。而页面的降级则会在`fast memory`处于压力状态时触发，利用`kswapped`将位于`inactive list`的page降级。



### 页面迁移的步骤

* 系统必须陷入内核（比如通过page fault）
* 迁移的页面的页表项必须被locked，避免被其他（线程、进程、应用etc.）访问，同时必须解除映射
* TLB Shootdown也会被报告给处理器
* 页面将在不同的tier间完成复制
* 最后页表需要完成重映射

页面的迁移可以同步也可以异步的进行，比如TPP就是应用的同步升级和异步降级。同步操作的执行将阻塞用户态程序直至页面迁移完成。异步迁移将页面的迁移从整个操作的关键路径中移除。OS课程已经学过同步是一件代价比较高的事情，在页面迁移的同步中，是需要引入page fault。

<img src=".\nomad_p2.png" style="zoom:50%;" />

上图是TPP同步升级和异步降级的breakdown，可以看见，同步的页面升级引入了巨大的开销，page-fault-timr几乎占据了20%的时间，用户态程序才能执行。异步降级使用kswapped启用了另一个CPU，就有了大量的CPU空闲时间。

TPP解耦了page allocation和memory reclaiming，但是仍然没有将页面迁移从关键路径中移除。Memtis启用了一个后台线程完成页面的升级降级,从而实现页面迁移从关键路径中移除。



## Nomad Design

Nomad 2 key features

* non-exclusive (Note: 不等于inclusive) memory tiering 
* transaction page migration

Nomad整体设计目标非常简单，就是能让处理器同时在快速内存和慢速内存里面访问页面。将页面迁移的代价从用户访问的关键路径中移除。Nomad并不会对页面的分配策略进行改变，然后逐渐的进行冷热数据的迁移。

第一个non-exclusive memory tiering 的特征，显著标记了一下不等于inclusive。这里的non-exclusive指的是保留了slow memory被迁移到fast memory的影子页面副本(shadow page copy)。Nomad声称这带来的好处是位于快速内存的冷页面如果是干净的，降级时只需要修改一下PTE。

> 问题是，假设是一个10GB+10GB的内存组合，如果我需要为快速内存的页面保留一份shadow copy在slow memory里面，岂不是冷内存的容量几乎都用于来干保留shadow copy了？？这或许和页面初始分配有关系，然而无论如何，快速内存里由slow memory迁移过来的内存从直觉上不一定少吧？即使是仅仅3GB，在这个例子中就相当于浪费了30%的冷内存和15%的内存容量。一旦workload的Memory Footprint比较大，这样的内存容量甚至会出现Out of Memory !!! 不清楚文章后续有没有解释这一个事情！！



至于提到的第二个特征，主要就是把unmap操作从传统三步走的unmap-copy-remap中移除。核心思想在于，在copy的过程中，shadow copy不会被locked，依然能够被应用程序访问。

当copy结束，Transaction Page Migration (TPM)会检查这个page是不是脏了，如果脏了，本次迁移会被废弃。如果干净，则会锁住页面，并修改对应PTE使其指向Fast Memory。

这个TPM的机制总感觉有些眼熟，似乎vTMM(EuroSys'23)年的工作就已经做过了。得check一下。





