# CortenMM (SOSP'25)

【Title】CortenMM: Efficient Memory Management with  Strong Correctness Guarantees



## Comments



## Abstract

现代内存管理系统存在性能低下和并发错误难以察觉的问题，既拖慢应用程序运行速度，又引入安全隐患。我们观察到这两个问题均源于传统内存管理系统的双层抽象设计：

* 软件层抽象（如Linux中的VMA树）
* 硬件层抽象（通常为页表）

该设计虽提升了可移植性，但需要正确且高效地同步两种截然不同的复杂数据结构，这通常极具挑战性。

本文提出CortenMM，一种全新设计的内存管理系统，旨在同时实现高性能与同步正确性。我们的核心见解是：**由于主流指令集架构的硬件内存管理单元格式近乎一致，多数操作系统已不再需要软件层抽象**。因此，CortenMM突破传统设计，通过消除软件层抽象实现彻底简化。基于此简化优势，CortenMM提出具备可扩展锁协议的事务性接口来编程MMU，通过避免软件层抽象中的额外竞争实现高性能。单层设计进一步支持我们对MMU并发操作代码（基础操作与锁协议的正确性）进行形式化验证，从而提供强有力的正确性保证。评估表明，经形式化验证的CortenMM在现实应用中的性能超越Linux达1.2倍至26倍。



## Introduction

内存管理系统作为任何操作系统的核心组件，负责管理内存资源并编程MMU硬件（即页表和TLB）。共享内存多线程技术作为利用现代多核处理器的主流方式，其运行依赖于内存管理系统。为避免成为性能瓶颈，内存管理系统必须高效处理来自多线程的请求。共享内存多线程技术作为利用现代多核处理器的主流方式，其运行依赖于内存管理系统。为避免成为性能瓶颈，内存管理系统必须高效处理来自多线程的请求。

> 其他内核优化工作，比如Linux 内核把VMA树从 RBTree(红黑树) 变成maple tree来更好的适应并发性。之前我也尝试过进一步优化maple tree，但还是偏向于工程优化，没有太多发paper的价值。等毕业了，再把这个工作延续下去。

然而，尽管经过数十年发展，现代内存管理在性能与正确性方面仍面临挑战。即使经过一系列优化改进，Linux内存管理仍是多线程应用可扩展性的严重瓶颈。部分学术研究提出了复杂的数据结构和/或高级并发控制机制，但如图1所示，内存管理的可扩展性依然不足。Linux开发者报告称，此类性能瓶颈会拖慢重要实际任务（如Android应用启动）的执行速度。更严重的是，内存管理系统的性能优化往往十分复杂，因而极易出现并发错误，进而引发安全漏洞。



本文提出CortenMM,一种新型内存管理系统，兼具高性能与强正确性保证。CortenMM采用全新设计，是从头开发生产级操作系统的宏观计划的重要组成部分。我们的目标是构建一个支持主流指令集架构（即x86、ARM和RISC-V）的通用操作系统，并能在各类生产环境（包括可信执行环境、数据中心和移动计算）中作为Linux的即插即用替代方案。

CortenMM的设计满足三大核心需求：

* 功能完备性：必须向应用程序提供相同接口，并支持应用常依赖的高级语义（如按需分页与写时复制）；
* 高性能：不得成为现代应用（尤其是多线程应用）的性能瓶颈；
* 同步正确性：必须提供强大的并发正确性保证，而非仅依赖测试验证。

为满足上述需求，CortenMM的设计基于我们对内存管理系统性能与正确性缺陷根源的观察：这些缺陷源于其采用的双层抽象架构。具体而言，大多数操作系统包含：

* 软件层抽象，例如Linux中存储进程虚拟内存区域集合的平衡树结构；
* 硬件层抽象，例如页表。这种可追溯至1986年SunOS的设计目标在于：
  * 提升对不同MMU硬件的可移植性
  * 支持高级内存语义（如按需分页）

而为确保可移植性，软件层抽象的数据结构必须具备通用性，因而难以与硬件层抽象的数据结构保持相似。遗憾的是，正确同步两种截然不同的数据结构需要复杂的并发控制，从而引发难以察觉的并发错误。此外，双层抽象通常会产生更多同步开销，进而降低系统可扩展性。

> 深有体会啊，之前还做了新型页表机制的探索，最难处理的还是并发控制，感兴趣的可以看一下我的[P3]([LujhCoconut/p3: P3: The Predict-Verify Paradigm for Accelerating (Minor) Page Fault Handling](https://github.com/LujhCoconut/p3))。大概就是改了内核mm里的很多东西。本来设想的是纯软件实现一个 xxxxx (这个还是不说了)，后面发现还是要改 MMU，就跑偏了。最后就一个半成品的东西，然后也没什么场景能用上。



我们的核心洞察在于：**针对主流指令集架构（如x86、ARM和RISC-V）的操作系统已不再需要软件层抽象**。

* 这是因为与过去内存管理单元存在较大差异（如分段机制、哈希页表）的情况不同，上述主流指令集架构均统一采用多级基数树页表。现代操作系统通过语言特性（例如C语言宏）来屏蔽这些MMU间的细微差异，而非依赖软件层抽象。此外，虽然提供高级内存语义需要在MMU之外存储额外状态，但这并不要求解耦出不同层次的抽象及其带来的复杂性。
* 基于以上分析，CortenMM通过消除软件层抽象突破了传统设计范式。它转而利用语言特性维持可移植性，并将页表中每个页面对应一个辅助内存区域，该区域仅存储支持高级语义所需的最简信息。这种极致的简化为我们设计高性能且直观的并发控制机制奠定了基础，具体细节将在下文详述。



CortenMM引入**事务接口**作为**编程MMU**的唯一方式。

* 该事务接口以 *虚拟内存区域* 和 *一系列在该区域内操作* 的基本指令（如映射或取消映射页面）作为输入。
* CortenMM随后以原子方式应用事务内的所有基本操作，从而显著简化了并发控制的推理过程。
* 此外，事务接口的锁协议不会因软件层抽象而产生额外竞争，因此在确保原子性的同时实现了高性能。
* 我们设计了两种锁协议：一种是基于读写锁的简单协议（CortenMMrw），另一种是基于RCU实现的无锁页表遍历的高级协议（CortenMMadv）。

CortenMM最终通过编程语言技术提供强大的同步正确性保证。我们的行业合作伙伴认为，仅依靠测试不足以验证复杂而关键的内存管理系统，特别是对于CortenMM这类全新设计。因此，凭借其简洁性和清晰的并发控制语义，我们成功对操作MMU（CortenMM的核心组件）的并发代码进行了**形式化验证**。

我们证明了：

* 事务接口中基本操作（映射、取消映射等）的功能正确性；
* 两种锁协议的正确性。对于其他组件，我们使用安全Rust确保其具备内存安全性、无数据竞争特性，且仅能通过已验证的事务接口访问MMU。



## Background

这项工作的背景是学术界研究者与工业界实践者合作，旨在从头开发名为Asterinas的生产级操作系统。作为这一宏观项目的一部分，我们正深入探究在内存管理系统中突破长期沿用的软件层抽象可能带来的潜在优势。



### Building a Production OS from Scratch

> 本来这段忽略的，但是 好的工作 就是需要宣传的

我们的操作系统Asterinas旨在成为通用型系统，适用于多种生产环境。其目标是成为可在主流指令集架构（即x86、ARM和RISC-V）上替代Linux的生产级开源方案。开发团队目前约有三十名成员，其中十二名为全职工程师。Asterinas的核心部分（不包括驱动程序）由13万行代码构成。为兼容现有应用程序，Asterinas提供了与Linux相同的系统调用接口，并复现了其关键特性。截至本文撰写时，我们已实现Linux中最常用的336个系统调用中的219个，能够运行JVM和MySQL等大型应用。



### Current MM: the Good, the Bad, and the Ugly

> 这title,似曾相识啊！ 肇老师的SIGMOD的一篇论文好像也是这个题目，背后应该有什么典故

本小节将评述基于双层抽象的传统内存管理系统设计的优势与不足。



#### The Good

**积极方面**在于支持高级内存管理语义并提升可移植性。我们追溯至1986年的SunOS，这是最早引入双层抽象的设计。软件层抽象将进程地址空间表示为虚拟内存区域的集合（沿用Linux术语称为VMA）。每个VMA代表一组具有相同属性（如访问权限）的连续虚拟页面。

SunOS引入软件层抽象基于两个原因：

* 首先，VMA维护了硬件MMU中不存在的状态信息，这些信息对实现高级内存管理语义至关重要。例如，为支持按需分页，操作系统初始仅将内存映射区域反映在VMA中，后续根据需求（如发生页错误时）再将变更传播至硬件MMU
* 软件层抽象使多数内存管理代码与硬件解耦，便于移植到多种硬件MMU架构（包括分段式、倒排式、哈希式和线性页表），部分架构甚至采用软件TLB。

这种双层抽象设计已成为内存管理系统的标准范式。20世纪90年代，当时的两大主流操作系统Linux和BSD均继承了该设计。如今，大多数现代操作系统——包括成熟的工业级系统（如Linux、FreeBSD、Solaris、Windows、Fuchsia和鸿蒙）以及学术提案（如K42、Barrelfish、NrOS、Bonsai和RadixVM）——均采用此设计架构。



#### The Bad

**弊端：复杂的并发控制协议**。随着现代服务器普遍配备数百个核心，双层抽象的一个缺陷日益凸显：需要复杂的细粒度并发控制。以下我们以最新Linux设计为例进行说明。

为平衡可移植性、功能支持度以及单核/多核性能，Linux中的软件层抽象已演变为基于区间索引的平衡树（现为RCU安全的maple-tree）：节点通过记录起始和结束内存地址来存储整个VMA。软件层抽象的数据结构针对高级内存管理操作进行了优化，且为保持可移植性，未与任何特定硬件MMU绑定。

> 在这文章出来之前，我还真搞过maple-tree based VMA的优化，但又变成工程优化了（工程优化也挺好，但在国内落后paper就要挨打，man, what can I say ?）。

Linux内存管理采用四种不同的锁机制

* `mmap_lock`: 保护整个地址空间
* VMA锁（保护单个VMA）
* 粗粒度页表锁（保护三级页表以上的所有条目，这些条目更接近页表根节点）
* 细粒度页表锁（每个锁保护二级或一级页表中的一个页面）

> 前两种VMA相关锁为读写锁，后两种页表锁为排他锁



单独针对VMA或页表的规则相对简单，但基本内存操作的规则却复杂得多，需要同时处理两个层次的锁。

* 所有操作必须至少持有VMA读锁，以防止VMA被并发删除或修改。随后仅在写入页表时才获取页表锁。
* 释放页表条目是个例外：要求代码先清空条目，因此只需持有VMA锁。



真正的挑战在于**处理完整操作（如系统调用mmap、munmap和页错误）**

* 此类操作涉及多个VMA，并组合执行多个基本操作（例如先遍历页表再插入条目）

> 这些场景的锁规则难以从表1推导，仅通过代码文档化



#### The Ugly

**症结：多核应用的可扩展性瓶颈与并发缺陷**。尽管存在前述复杂的细粒度并发控制机制，Linux内存管理仍是多线程应用公认的可扩展性瓶颈。若干学术研究试图通过新型数据结构设计和/或高级并发控制来缓解此类开销，但效果仍不理想。据报告，内存管理瓶颈会严重影响实际应用场景：例如显著降低Android应用启动速度、Google Fibers中的线程创建效率以及TCP零拷贝性能。

更严重的是，现代内存管理系统易受微妙并发缺陷的影响，进而引发严重安全漏洞。以Linux为例：其在2023年4月引入了上述细粒度并发控制机制，而在此后两年内，该新变更已导致十个CVE漏洞（均源于并发错误）。这十个漏洞中，九个可被利用来使系统崩溃，五个可能引发信息泄漏和权限提升等高危漏洞。

> 并发控制真是.....有意思啊

