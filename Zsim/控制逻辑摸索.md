# ZSim控制逻辑(banshee源码为例)

## 简单逻辑

`banshee/buil/opt/init.cpp line337`

```c++
} else if (type == "DramCache") {
		mem = new MemoryController(name, frequency, domain, config);
```

此处调用`MemoryController`，接收参数为`type`，定义如下：

```c++
string type = config.get<const char*>("sys.mem.type", "Simple");
```

该`config`指的是`test`目录下的`.cfg`类型的文件，执行方式为命令行执行即可，较为简单

```shell
./build/opt/zsim tests/xxx.cfg
```

使用`diff`命令比较`banshee`与原生ZSim的`init.cpp`比较，除了上述改动之外，其余改动只是部分函数增加了`config`参数，因此`init.cpp`的逻辑几乎不用动。只需新增一个`else if (type == "xxxx") {mem = new XXX(name,frequency,domain,config)};`

因此，**似乎**只需要写好控制器，就能够完成整个系统的逻辑。至于统计输出也在控制器层面实现。



## MemoryController —— 构造

以`banshee`实现为例，代码篇幅较长，大部分略去：

### 构造函数

**构造函数初始化成员变量**

- `_name`: 传入的内存控制器名称。
- `_collect_trace`: 是否收集内存访问跟踪。通过配置文件中的 `sys.mem.enableTrace` 参数决定。**如果启用跟踪且当前控制器是 `mem-0`，则初始化跟踪文件路径和文件。**
- `_sram_tag`: 配置是否启用 SRAM 标记（从 `sys.mem.sram_tag` 获取）。
- `_llc_latency`: 配置 L3 缓存的延迟。
- `_ext_type`: 外部 DRAM 类型（通过 `sys.mem.ext_dram.type` 配置，可能是 Simple、DDR、MD1 或 DRAMSim）。
- `_scheme`: 内存控制器的缓存方案，通过 `sys.mem.cache_scheme` 配置，可能是 `NoCache`、`AlloyCache`、`UnisonCache`、`HybridCache` 等。
- `_bw_balance`: 是否启用带宽平衡（通过 `sys.mem.bwBalance` 配置）。



**外部 DRAM 配置**

外部 DRAM 的类型通过 `_ext_type` 配置，支持多种类型：

- **Simple**: 使用 `SimpleMemory` 模型初始化外部 DRAM。
- **DDR**: 使用 `BuildDDRMemory` 函数创建 DDR 内存模型。
- **MD1**: 使用 `MD1Memory` 创建一种新的 DRAM 模型。
- **DRAMSim**: 使用 `DRAMSimMemory` 模型，并加载相关的配置文件。



**内存控制器缓存配置**

这里的Cache指的是DRAMCache，根据缓存方案（`_scheme`），初始化不同类型的缓存结构。缓存方案包括：

- `AlloyCache`: 特定的缓存策略，要求 `granularity` 为 64 字节，`num_ways` 为 1。
- `UnisonCache`: 另一种缓存策略，要求 `granularity` 为 4096 字节。
- `HybridCache`: 混合缓存策略，支持 4KB 或 2MB 页。
- `NoCache`: 没有缓存。
- `Tagless`: 不使用标签的缓存策略。

如果方案是 `AlloyCache`、`UnisonCache` 或 `HybridCache`，会根据配置初始化相关的缓存放置策略（例如，`LinePlacementPolicy`、`PagePlacementPolicy`）。



**内存控制器模型的初始化**

- 内存控制器的缓存模型（如 `SimpleMemory`、`DDR`、`MD1Memory`、`DRAMSimMemory`）通过不同的类型和配置进行初始化。
  - 片上堆叠内存或者HBM即这段代码中出现的`mc_dram`。
  - 代码中根据`ext_dram`和`mc_dram`的类型选择对应的内存初始化
- 缓存放置策略根据缓存方案不同被配置成不同的类型（如 `LinePlacementPolicy`、`OSPlacementPolicy`、`PagePlacementPolicy`）

![](D:\homepage\Zsim\zsim-l1-p1.png)

在`banshee/test/test.cfg`中，`ext_dram`和`mc_dram`都使用的`DDR`

```c++
mem = {
    enableTrace = false;
	mapGranu = 64;
    controllers = 2;
    type = "DramCache";
	# cache_scheme: AlloyCache, HybridCache (Banshee), UnisonCache, Tagless
	cache_scheme = "AlloyCache"; 
    ext_dram = {
      type = "DDR";
	  ranksPerChannel = 4;
	  banksPerRank = 8;
    };
    mcdram = {
	  ranksPerChannel = 4;
	  banksPerRank = 8;
      cache_granularity = 64;
      size = 512;
      mcdramPerMC = 8;
	  num_ways = 1;
      sampleRate = 1.0;
	  # placementPolicy: LRU, FBR 
      placementPolicy = "LRU";
      type = "DDR";
    };
  };
```

由于都选用了DDR作为`ext_dram`和`mc_dram`的类型，代码中实际调用了`MemoryController::BuildDDRMemory`函数：

```c++
DDRMemory* 
MemoryController::BuildDDRMemory(Config& config, uint32_t frequency, 
								 uint32_t domain, g_string name, const string& prefix, uint32_t tBL, double timing_scale) 
{
    uint32_t ranksPerChannel = config.get<uint32_t>(prefix + "ranksPerChannel", 4);
    uint32_t banksPerRank = config.get<uint32_t>(prefix + "banksPerRank", 8);  // DDR3 std is 8
    uint32_t pageSize = config.get<uint32_t>(prefix + "pageSize", 8*1024);  // 1Kb cols, x4 devices
    const char* tech = config.get<const char*>(prefix + "tech", "DDR3-1333-CL10");  // see cpp file for other techs
    const char* addrMapping = config.get<const char*>(prefix + "addrMapping", "rank:col:bank");  // address splitter interleaves channels; row always on top

    // If set, writes are deferred and bursted out to reduce WTR overheads
    bool deferWrites = config.get<bool>(prefix + "deferWrites", true);
    bool closedPage = config.get<bool>(prefix + "closedPage", true);

    // Max row hits before we stop prioritizing further row hits to this bank.
    // Balances throughput and fairness; 0 -> FCFS / high (e.g., -1) -> pure FR-FCFS
    uint32_t maxRowHits = config.get<uint32_t>(prefix + "maxRowHits", 4);

    // Request queues
    uint32_t queueDepth = config.get<uint32_t>(prefix + "queueDepth", 16);
    uint32_t controllerLatency = config.get<uint32_t>(prefix + "controllerLatency", 10);  // in system cycles

    auto mem = (DDRMemory *) gm_malloc(sizeof(DDRMemory));
	new (mem) DDRMemory(zinfo->lineSize, pageSize, ranksPerChannel, banksPerRank, frequency, tech, addrMapping, controllerLatency, queueDepth, maxRowHits, deferWrites, closedPage, domain, name, tBL, timing_scale);
    return mem;
}
```



**MC_DRAM额外设置**

由于`banshee`的论文，把`mc_dram`当成DRAMCache，因此在源代码中这部分主要就是设置`banshee`作为DRAMCache的模式：

- `AlloyCache`
  -  是一种直接映射的 DRAM 缓存，它以细粒度存储数据。每个集合的标签和数据在 DRAM 缓存中是相邻存储的。对于每次标签探测，数据也会被预取加载。因此，在缓存命中时，延迟大致相当于一次 DRAM 访问的延迟。在缓存未命中时，Alloy Cache 会产生片上 DRAM 访问的延迟加上片外 DRAM 访问的延迟。在带宽消耗方面，Alloy Cache 需要 **1）**从 DRAM 缓存中加载标签和数据，**2）**从片外 DRAM 中加载数据，**3）**将访问的标签和数据插入 DRAM 缓存。因此，**未命中和替换时，延迟和带宽消耗都会翻倍**。原始的 **Alloy Cache** 论文 提出了**并行发起**对内包和片外 DRAM 的请求，以隐藏未命中延迟。**然而，banshee假设采用的实现是串行访问，因为预取访问片外 DRAM 会显著增加对已经有限的片外 DRAM 带宽的压力。**
- `UnisonCache`
  - 以粗粒度存储数据并支持集合关联性。该设计依赖于路径预测来提供较低的命中延迟。在访问时，内存控制器读取集合中所有标签，并**仅从预测的路径加载数据。数据加载是预取的。**在命中并且路径预测正确的情况下，延迟大致相当于一次 DRAM 访问，因为预取的数据和标签访问一起返回。然后，标签会与更新后的 LRU 位一起存回内包 DRAM。**对于未命中的情况，由于额外的片外 DRAM 访问，延迟会翻倍。**在缓存未命中的带宽消耗方面，Unison Cache **1）**加载预测路径中的标签和数据，**2）**进行缓存替换，将预测的页面足迹加载到片上 DRAM 中，**3）**将更新后的标签和 LRU 位存回 DRAM 缓存。**如果页面足迹较大，缓存未命中和替换时的带宽消耗可能是缓存命中时的几十倍。**
- `HybridCache`
  - 不清楚是不是指的是论文中出现的HMA，如果是的话：
  - 采用基于软件的解决方案来处理这些问题。操作系统（OS）定期对所有页面进行排名，并将热页面移入内包 DRAM（冷页面移出）。操作系统更新所有页表项（PTE），刷新所有 TLB 以保持一致性，并从所有片上缓存中刷新重新映射物理页面的缓存行以确保地址一致性。由于这个过程的高性能开销，重新映射只能以非常粗粒度（例如，100 毫秒到 1 秒）进行，以便摊销开销。**因此，DRAM 缓存替换策略可能无法充分捕获应用程序中的时间局部性。此外，当页面在内包和外包 DRAM 之间移动时，系统中所有正在运行的程序都必须停止，这会导致不希望出现的性能下降。**
- `NoCache`
- `Tagless`:
  - 也采用地址重映射，但通过硬件管理的 TLB 一致性机制实现了频繁的缓存替换。具体来说，TDC 在主存中维护一个 TLB 目录结构，并在每次条目被插入或从系统中的任何 TLB 中移除时更新该目录。这种细粒度的 TLB 一致性带来了额外的设计复杂性。此外，随着核心数量的增加，目录的存储成本可能成为潜在的可扩展性瓶颈。TDC  没有讨论地址一致性问题，因此不清楚 TDC 是否采用了某种解决方案来解决地址一致性问题，或者是否存在这种解决方案。



## MemReq

`memory_hierarchy.h`

`MemReq` 结构体表示一个内存请求，它包含了请求的地址、访问类型、MESI 状态、请求到达的周期、同步锁等信息。标志位用于标记请求的特殊行为，例如指令获取、预取、写回等。通过这些信息，系统能够管理内存访问、同步、缓存一致性等任务。

```c++
/* Memory request */
struct MemReq {
    Address lineAddr;
    AccessType type;
    uint32_t childId;
    MESIState* state;
    uint64_t cycle; //cycle where request arrives at component

    //Used for race detection/sync
    lock_t* childLock;
    MESIState initialState;

    //Requester id --- used for contention simulation
    uint32_t srcId;

    //Flags propagate across levels, though not to evictions
    //Some other things that can be indicated here: Demand vs prefetch accesses, TLB accesses, etc.
    enum Flag {
        IFETCH        = (1<<1), //For instruction fetches. Purely informative for now, does not imply NOEXCL (but ifetches should be marked NOEXCL)
        NOEXCL        = (1<<2), //Do not give back E on a GETS request (turns MESI protocol into MSI for this line). Used on e.g., ifetches and NUCA.
        NONINCLWB     = (1<<3), //This is a non-inclusive writeback. Do not assume that the line was in the lower level. Used on NUCA (BankDir).
        PUTX_KEEPEXCL = (1<<4), //Non-relinquishing PUTX. On a PUTX, maintain the requestor's E state instead of removing the sharer (i.e., this is a pure writeback)
        PREFETCH      = (1<<5), //Prefetch GETS access. Only set at level where prefetch is issued; handled early in MESICC
    };
    uint32_t flags;

    inline void set(Flag f) {flags |= f;}
    inline bool is (Flag f) const {return flags & f;}
};
```

### 主要字段解释

1. **地址 (`lineAddr`)**：
   - `lineAddr` 存储了与该内存请求相关的内存地址（通常是缓存行地址）。这通常是一个表示地址的类型（如 `uint64_t`）。
   - 该地址用于标识请求操作的缓存行或内存块。
2. **访问类型 (`type`)**：
   - `type` 是一个枚举类型，表示内存请求的类型（比如读取、写入等）。具体的类型定义在 `AccessType` 枚举中（该部分代码未显示）。常见的类型有 `READ`、`WRITE` 或者特定的访问类型（如 `IFETCH` 用于指令获取）。
3. **子请求 ID (`childId`)**：
   - `childId` 用于标识子请求的 ID。这个字段可能与事务或内存操作的级别相关，帮助追踪请求的源头。
4. **MESI 状态 (`state`)**：
   - `state` 指向一个 `MESIState` 对象，该对象表示内存请求时该缓存行的 MESI 状态。MESI 协议用于跟踪缓存行在多个缓存之间的状态，确保数据一致性。
5. **请求到达周期 (`cycle`)**：
   - `cycle` 表示请求到达组件的周期，通常用于模拟时间和延迟，确保在正确的时钟周期进行内存操作。
6. **子锁 (`childLock`)**：
   - 这个字段用于同步或竞争检测。它是一个锁指针，用于防止不同组件或处理器间的竞态条件，确保内存请求的正确同步。
7. **初始状态 (`initialState`)**：
   - `initialState` 存储请求发起时缓存行的初始 MESI 状态。这个状态在处理过程中用于检测是否发生了状态变化。
8. **请求源 ID (`srcId`)**：
   - `srcId` 表示发起请求的源的 ID，用于模拟请求的来源，通常用于处理内存访问争用或追踪访问源。

### 标志位 (`flags`)

`flags` 字段使用了一组标志位，表示不同的内存请求特征，这些标志在内存请求传播或缓存一致性处理过程中起到了重要作用。以下是各个标志位的作用：

1. **`IFETCH`**：
   - 表示这是一次指令获取操作。通常用于指令读取，主要用于区分与数据访问的请求。该标志用于表示这是一次纯粹的指令请求，但不会影响缓存一致性协议中的排他性（`NOEXCL`）。
2. **`NOEXCL`**：
   - 表示在进行 `GETS` 请求时，不需要返回排他（Exclusive）状态，即缓存一致性协议在这一请求中变为 MSI（Modified, Shared, Invalid）协议，而不是标准的 MESI 协议。
3. **`NONINCLWB`**：
   - 表示这是一次非包含性写回。该请求不会假定目标缓存行已经在较低层次的缓存中，常见于某些非统一缓存架构（如 NUCA）。
4. **`PUTX_KEEPEXCL`**：
   - 用于 PUTX 请求时，保持请求源的排他性状态（E），而不是移除共享者。用于写回操作，确保在写回时不会影响该缓存行的排他状态。
5. **`PREFETCH`**：
   - 表示这是一次预取请求。预取请求在处理时通常与正常的内存访问有所不同，可能不需要参与完整的缓存一致性协议。

### 内联函数

- **`set(Flag f)`**：将特定的标志位设置为 1。用于在请求中标记特定的操作类型。
- **`is(Flag f)`**：检查是否设置了特定的标志位。如果标志位已设置，返回 `true`。



### InvReq

```c++
/* Invalidation/downgrade request */
struct InvReq {
    Address lineAddr;
    InvType type;
    // NOTE: writeback should start false, children pull it up to true
    bool* writeback;
    uint64_t cycle;
    uint32_t srcId;
};
```



### 其它

```c++
typedef enum {
    // 获取缓存行的副本，不需要独占权限（例如处理器进行加载操作）。这个请求通常表示从缓存中读取数据，且允许多个处理器共享这个缓存行。不会要求排他性（Exclusive）权限。
    GETS, 
    // 获取缓存行并且需要独占权限（例如处理器进行存储或原子操作）。这个请求通常表示一个处理器需要对缓存行进行写入，并要求其他处理器无法访问这个缓存行的副本，因此需要独占权限。
    GETX, 
    // 写回操作，表示将缓存行从缓存中“清洁”地写回到更低层次的缓存，且该缓存行未被修改（没有脏数据）。这个操作通常发生在较低层次的缓存（例如 L2 或 L3）将缓存行从其缓存中逐出时。
    PUTS, 
    // 写回操作，表示将缓存行从缓存中“脏”地写回到更低层次的缓存，且该缓存行已经被修改（有脏数据）。这种操作通常用于将修改过的数据写回到较低层次的缓存，或者当缓存行被逐出时。
    PUTX  
} AccessType;

/* Types of Invalidation. An Invalidation is a request issued from upper to lower
 * levels of the hierarchy.
 */
typedef enum {
    // 完全失效该缓存行。即使该缓存行在较低层次的缓存中被共享，也会使其无效，并要求缓存行被删除。
    INV,  
    // 失效该缓存行的独占访问权限（即失效排他性）。这个请求允许较低层次的缓存保留一个非独占的副本，但失效该缓存行的排他性状态。通常用于使其他处理器能够访问该缓存行，但失效该行的排他访问权限。
    INVX, 
    // 不失效该缓存行，而是仅将数据发送给上层请求者。这个操作通常在目录（如目录缓存）中使用。它仅适用于缓存行处于共享（S）状态的情况下，且不会导致缓存行被失效。
    FWD,  
} InvType;

/* Coherence states for the MESI protocol */
typedef enum {
    I, // invalid 缓存行处于失效状态，意味着该缓存行不包含有效的数据，缓存行可以被其他处理器访问或加载数据。
    S, // shared (and clean) 缓存行处于共享状态，表示该缓存行可以被多个处理器共享且没有被修改。该行的副本存在于多个缓存中，且所有缓存行都是只读的
    E, // exclusive and clean 缓存行处于独占状态，意味着该缓存行仅存在于当前缓存中且未被修改。当前缓存是该缓存行的唯一副本，并且数据可以被修改（写入）
    M  // exclusive and dirty 缓存行处于脏状态，意味着缓存行的副本是唯一的且已被修改。该缓存行包含的数据已被修改，且它未被写回到主内存中
} MESIState;
```



### MemoryController —— Access

