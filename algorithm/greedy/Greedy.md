# 贪心

## 模板题

### G1) 合并果子 

> **标签**： # NOIP2004 提高组， # 洛谷 P1090

**题目描述**:

在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。

每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过 $n−1$ 次合并之后， 就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。

因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为 1 ，并且已知果子的种类 数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。

例如有 3 种果子，数目依次为 1 ， 2 ， 9 。可以先将 1 、 2 堆合并，新堆数目为 3 ，耗费体力为 3 。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为 12 ，耗费体力为 12 。所以多多总共耗费体力 =3+12=15 。可以证明 15 为最小的体力耗费值。

```C++
/* 小根堆 */
priority_queue<int,vector<int>,greater<int>>q; 

int n,x; scanf("%d",&n);
for(int i = 0; i < n; i++)
    scanf("%d",&x), q.push(x);

int res = 0;
while(q.size()>1){
    int a = q.top(); q.pop();
    int b = q.top(); q.pop();
    res += a+b;
    q.push(a+b);
}

printf("%d\n",res);
```

* 小根堆相关概念

> **`priority_queue`**是C++ STL（标准模板库）提供的优先队列容器，默认实现的是**大根堆（Max Heap）**，即队首元素是当前队列中的最大值。通过模板参数可以自定义堆的类型（大根堆或小根堆）。
>
> * **`int`**：堆中存储的元素类型（这里是整数）。
> * **`vector<int>`**：底层容器类型，用于存储堆元素（默认是`vector`）。
> * **`greater<int>`**：比较函数对象，用于定义堆的排序规则。
>   * `greater<int>`是C++标准库提供的**函数对象**（类似比较器），它会将元素按**升序**排列。
>   * 因此，`priority_queue`使用`greater<int>`后，队首元素变为当前队列中的**最小值**，从而实现**小根堆**。
>
> 
>
> 小根堆的特性：
>
> **队首元素（`q.top()`）**：始终是当前堆中的最小值。
>
> **插入元素（`q.push(x)`）**：时间复杂度为 $O(logn)$。
>
> **弹出队首（`q.pop()`）**：时间复杂度为 $O(logn)$。
>
> **底层实现**：通常是一个二叉堆（用`vector`动态数组存储）。
>
> * 小根堆常用于需要**快速获取最小值**的场景（如Dijkstra算法、哈夫曼编码等）。



### **G2)** 奶牛玩杂技

> 标签： # USACO 2005, #洛谷 P 1842

**题目背景**:

Farmer John 养了 *$N$* 头牛，她们已经按 $1∼N$ 依次编上了号。FJ 所不知道的是，他的所有牛都梦想着从农场逃走，去参加马戏团的演出。可奶牛们很快发现她们那笨拙的蹄子根本无法在钢丝或晃动的的秋千上站稳（她们还尝试过把自己装在大炮里发射出去，但可想而知，结果是悲惨的） 。最终，她们决定练习一种最简单的杂技：把所有牛都摞在一起， 比如说， 第一头牛站在第二头的身上， 同时第二头牛又站在第三头牛的身上...最底下的是第 *$N$* 头牛。

**题目描述**:

每头牛都有自己的体重以及力量，编号为 $i $的奶牛的体重为 $W_{i}$，力量为 *$S_{i}$*。

当某头牛身上站着另一些牛时它就会在一定程度上被压扁，我们不妨把它被压扁的程度叫做它的压扁指数。对于任意的牛，她的压扁指数等于摞在她上面的所有奶牛的总重（当然不包括她自己）减去她的力量。奶牛们按照一定的顺序摞在一起后， 她们的总压扁指数就是被压得最扁的那头奶牛的压扁指数。

你的任务就是帮助奶牛们找出一个摞在一起的顺序，使得总压扁指数最小。

**输入格式**:

第一行一个整数 *$N$*。

接下来 *N* 行，每行两个整数 $W_{i}$和  *$S_{i}$*。

**输出格式**:

一行一个整数表示最小总压扁指数。



**直觉猜想：**越重力量越大的放在下面肯定是最好的，所以直觉上这种问题就是某种重量和力量这个二元组的函数 $f(w,s)$ 等于权重，最后按权重排序即可得到答案。 最简单的 $f(W,S)=W+S$ ,时间有限情况下可以直接这么做（尽管这就是答案）。理论上这个 $f(w,s)$  可以是 $W,S$ 线性组合,也可能是非线性，需要优化的。如果是比较变态的题，可能还需要借鉴梯度下降、凸优化等等去逼近最优解。本题无须如此：

**数学证明：**(领项交换法)
$$
\begin{aligned}
&Assume：f_{i}=f(W_{i},S_{i})=W_{i}+S_{i} ; \quad (W_{i},S_{i})\ 二元组按f(W,S)随\ i\  升序排列;\ 即f_{i}单调不减
\newline & res = \sum_{i=1}^{n-1}W_{i}-S_{n}; 
\newline & 交换\ n-1\ 行与\ n \ 行： res'= \sum_{i=1}^{n-2}W_{i}+W_{n}-S_{n-1};
\newline & res'-res = (\sum_{i=1}^{n-2}W_{i}+W_{n}-S_{n-1})-( \sum_{i=1}^{n-1}W_{i}-S_{n})=(W_{n}+S_{n})-(W_{n-1}+S_{n-1})=f_{n}-f_{n-1} \ge0
\newline & 由于n具有任意性，因此每步都是最优
\end{aligned}
$$

* **贪心选择性质**：我们可以通过安全的交换操作，保证存在一个最优解其底部牛是 $(w+s)$​最大的牛。

  * 贪心选择性质证明的常用思路就是交换论证：

    * >例子：有一组活动 $S=\{a_{1},a_{2},...,a_{n}\}$，每个活动  $a_{i}$ 有一个开始时间 $s_{i}$ 和结束时间 $f_{i}$ 。这些活动共享一个资源（例如一个教室），同一时间只能进行一个活动。如果两个活动的时间区间 $[s_{i},f_{i})$ 和 $[s_{j},f_{j}]$ 不重叠（即$ f_{i} \le s_{j}$或$ f_{j} \le s_{i}$），则称它们是兼容的。目标是选择最大的兼容活动集合。**贪心策略**：每次都选择**结束时间最早**的活动（即 $f_{i}$​​​ 最小的活动），然后移除与该活动时间冲突的所有活动，在剩余活动中重复这一过程。
      >
      >**第一步：证明贪心选择性质**
      >
      >**命题**：存在一个最大兼容活动集 *$A$*（即一个最优解），其包含的第一个活动是所有活动中结束时间最早的活动，记为 $a_{m}$。
      >
      >**证明（交换论证）**：
      >
      >(1) 设 *$O$*是任意一个最优解。设  *$a_{k}$* 是 *$O$* 中结束时间最早的活动。
      >(2) 现在，我们构造一个新的解 $O'$：用我们的贪心选择 $a_{m}$（全局最早结束的活动）替换掉 *O*中的 *$a_{k}$* ，即 *O*′=$(O∖{a_{k}})∪{a_{m}}$​
      >
      >(3) 我们需要证明 *O*′也是一个最优解（兼容且大小与 *O*相同）。
      >
      >**兼容性**：因为 *$a_{m}$*的结束时间$f_{m}$早于或等于$a_{k}$的结束时间$f_{k}$（*$a_{m}$*是全局最早结束的），所以$a_{m}$一定不会比 *$a_{k}$*更晚结束。因此，在最优解 *O*中，*$a_{k}$*之后的所有活动都与 $a_{k}$兼容（即开始时间 ≥$f_{k}$）。既然 *$f_{m}$*≤*$f_{k}$*，那么这些活动也一定与 *$a_{m}$兼容（因为它们的开始时间 ≥*$f_{k}$ ≥ $f_{m}$​）。所以 *O*′中的所有活动是兼容的。
      >
      >**大小**：我们用一个新的活动替换了一个旧的活动，集合的大小 ∣*O*′∣=∣*O*∣保持不变。
      >
      >因此，我们构造出的 *O*′是一个包含了贪心选择 $a_{m}$​​的最优解。**证毕**。
      >
      >
      >
      >**结论**：我们证明了存在一个最优解以贪心选择（最早结束的活动）作为第一步。问题具有贪心选择性质。

* **最优子结构**：在确定了底部牛之后，剩余牛的排列问题是一个规模更小的原问题，其最优解能构成原问题的最优解。

  从而此处贪心即是全局最优解。

```c++
const int N = 50010;
struct node{
    int w,s;
    bool operator<(node &t){
        return w+s < t.w+t.s;
    }
}a[N];

int main(){
    int n; cin>>n;
    for(int i=1; i<=n; i++)
        cin>>a[i].w>>a[i].s;
    sort(a+1,a+n+1);
    
    int res=-2e9, t=0;
    for(int i=1;i<=n; i++){
        res = max(res,t-a[i].s);
        t += a[i].w;
    }
    cout<<res<<endl;
}
```

> Q? 牛会不会被压垮？



### G3) 排队接雨水

> 标签：  #洛谷 P 1223

**题目描述**

有 $n$ 个人在一个水龙头前排队接水，假如每个人接水的时间为 $T_i$，请编程找出这 $n$ 个人排队的一种顺序，使得 $n$ 个人的平均等待时间最小。

一个人的等待时间不包括他的接水时间。

如果两个人接水的时间相同，编号更小的人应当排在前面。

**输入格式**

第一行为一个整数 $n$。

第二行 $n$ 个整数，第 $i$ 个整数 $T_i$ 表示第 $i$ 个人的接水时间 $T_i$。

**输出格式**

输出文件有两行，第一行为一种平均时间最短的排队顺序；第二行为这种排列方案下的平均等待时间（输出结果精确到小数点后两位）。

> 这种题目本质就是送分的，短的在前面就结束了，放在这里就是提出“贪心和排序往往是伴生的”，以及证明问题。

$$
\begin{aligned}
& 假设\ T_{i}\ 已经升序排列，则等待时间为\ T=(n-1)\cdot T_{1} + (n-2)\cdot T_{2} + ... +(n-i)\cdot T_{i}+(n-j)\cdot T_{j}+...
\newline & 交换论证（i,j）：T'=(n-1)\cdot T_{1} + (n-2)\cdot T_{2} + (n-i)\cdot T_{j} + (n-j)\cdot T_{i} +...
\newline & T'-T=((n-i)\cdot T_{j} + (n-j)\cdot T_{i})-((n-i)\cdot T_{i}+(n-j)\cdot T_{j})=(j-i)(T_{j}-T_{i})\ge0
\end{aligned}
$$

```c++
struct node{
    int t,id;
    bool operator<(node $b){
        return t<b.t;
    }
}a[1010];

int main(){
    int n; cin>>n;
    for(int i=1;i<=n;i++)
        cin>>a[i].t,a[i].id=i;
    sort(a+1,a+n+1);
    for(int i=1;i<=n;i++){
        cout<<a[i].id<<" ";
    }
    puts("");
    
    double time=0;
    for(int i=1;i<=n-1;i++)
        time += a[i].t * (n-i);
    
    printf("%.2lf",time/n);
}
```



### G4) 接水问题

> 标签：  # NOIP 2010 普及组  #洛谷 P 1190

**题目描述**

学校里有一个水房，水房里一共装有 $m$ 个龙头可供同学们打开水，每个龙头每秒钟的供水量相等，均为 $1$。

现在有 $n$ 名同学准备接水，他们的初始接水顺序已经确定。将这些同学按接水顺序从 $1$ 到 $n$ 编号，$i$ 号同学的接水量为 $w_i$。接水开始时，$1$ 到 $m$ 号同学各占一个水龙头，并同时打开水龙头接水。当其中某名同学 $j$ 完成其接水量要求 $w_j$ 后，下一名排队等候接水的同学 $k$ 马上接替 $j$ 同学的位置开始接水。这个换人的过程是瞬间完成的，且没有任何水的浪费。即 $j$ 同学第 $x$ 秒结束时完成接水，则 $k$ 同学第 $x+1$ 秒立刻开始接水。若当前接水人数 $n'$ 不足 $m$，则只有 $n'$ 个龙头供水，其它 $m - n'$ 个龙头关闭。 （$m\le n$）

现在给出 $n$ 名同学的接水量，按照上述接水规则，问所有同学都接完水需要多少秒。

**输入格式**

第一行两个整数 $n$ 和 $m$，用一个空格隔开，分别表示接水人数和龙头个数。

第二行 $n$ 个整数 $w_1,w_2,\ldots,w_n$，每两个整数之间用一个空格隔开，$w_i$ 表示 $i$ 号同学的接水量。

**输出格式**

一个整数，表示接水所需的总时间。

**输入输出样例 #1**

**输入 #1**

```
8 4
23 71 87 32 70 93 80 76
```

**输出 #1**

```
163
```



> 只要注意按顺序，这题每次往最小的上面接就好了

```c++
int n,m,w[10010]; // w: 每人的接水量
int s[110]; //s:每个水龙头的出水量

int main(){
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)scanf("%d",&w[i]);
    for(int i=1;i<=n;i++){
        t=1;
        // 找到出水量最小的水龙头
        for(int j=2;j<=m;j++)
            if(s[t]>s[j])t=j;
        s[t]+=w[i];
    }
    int mx=0;
    for(int i=1;i<-m;i++)mx = max(mx,s[i]);
    printf("%d\n",mx);
}
```



### G5) 修理牛棚

> 标签：  # USACO1.3  #洛谷 P 1209

**题目描述**

在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。   

牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度"1"。   

自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。

给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。

**输入格式**

一行三个整数 $m,s,c$，意义如题目描述。   
接下来 $c$ 行，每行包含一个整数，表示牛所占的牛棚的编号。

**输出格式**

输出一行一个整数，表示所需木板的最小总长度。

**输入输出样例 #1**

**输入 #1**

```
4 50 18
3 
4 
6 
8 
14
15 
16 
17 
21
25 
26 
27 
30 
31 
40 
41 
42 
43
```

**输出 #1**

```
25
```



```c++
int m,s,c,ans;
int a[N]; //牛棚编号
int d[N]; //相邻牛之间的牛棚数

int main(){
    scanf("%d%d%d",&m,&s,&c);
    for(int i=1;i<=c;i++)scnaf("%d",&a[i]);
    
    sort(a+1,a+c+1);
    for(int i=2;i<=c;i++)d[i-1]=a[i]-a[i-1]-1;
    sort(d+1,d+c);
    
    ans=c;
    if(m<c)
        for(int i=1;i<=c;i++)ans+=d[i];
    printf("%d\n",ans);
    return 0;
}
```



### G6) 奶牛晒衣服

> 标签： #洛谷 P 1843

**题目背景**

熊大妈决定给每个牛宝宝都穿上可爱的婴儿装 。但是由于衣服很湿，为牛宝宝晒衣服就成了很不爽的事情。于是，熊大妈请你（奶牛）帮助她完成这个重任。

**题目描述**

一件衣服在自然条件下用一秒的时间可以晒干 $a$ 点湿度。抠门的熊大妈只买了一台烘衣机 。使用用一秒烘衣机可以让一件衣服额外烘干 $b$ 点湿度（一秒晒干 $a+b$ 湿度），但在同一时间内只能烘一件衣服。现在有 $n$ 件衣服，第 $i$ 衣服的湿度为 $w_i$（保证互不相同），要你求出弄干所有衣服的最少时间（湿度为 $0$ 为干 ）。

**输入格式**

第一行三个整数，分别为 $n,a,b$。  
接下来 $2$ 到 $n+1$ 行，第 $i$ 行输入 $w_i$。

**输出格式**

一行，弄干所有衣服的最少时间。

**输入输出样例 #1**

**输入 #1**

```
3 2 1
1
2
3
```

**输出 #1**

```
1
```



* 使用**大根堆（优先队列）**来动态处理衣服的湿度，其核心思路是：
  * **每次选择当前最湿的衣服**（堆顶元素）用烘干机处理。
  * **自然晾晒**：所有衣服在 `res`秒内会自然减少 `res * a`湿度。
  * **烘干机处理**：每次烘干机减少 `b`湿度（但同一时间只能处理一件衣服）。
  * **终止条件**：当最湿的衣服的湿度 `<= res * a`（即自然晾晒已足够烘干），结束循环。

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
using namespace std;

const int N = 500010;
int n,a,b;
priority_queue<int> q;

int main(){
    scanf("%d%d%d",&n,&a,&b);
    for(int i=1;i<=n;i++){
        int x;scanf("%d",&x);
        q.push(x);
    }

    int res = 0;
    int mx = q.top(); 
    q.pop();
    while(mx > res*a){
        res ++;
        mx -= b;
        q.push(mx);
        mx=q.top();
        q.pop();
    }
    printf("%d\n",res);
    return 0;
}
```



### G7) 线段覆盖

> P1803 入门题，懒得写了

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 1e6+10;

int n;
struct node{
    int l,r;
    bool operator<(const node &w)
    {
        return r<w.r;
    }
}ns[N];

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d%d",&ns[i].l,&ns[i].r);

    sort(ns+1,ns+n+1);
        
    int res = 1;
    int lst = 1;

    for(int i=2;i<=n;i++)
    {
        if(ns[i].l>=ns[lst].r)
        {
            res += 1;
            lst = i;
        }
    }
    printf("%d\n",res);
    return 0;
}
```

 

### G8) 均分纸牌

> 标签： # NOIP 2002 提高组   # 洛谷 P 1031

**题目描述**

有 $N$ 堆纸牌，编号分别为 $1,2,\ldots,N$。每堆上有若干张，但纸牌总数必为 $N$ 的倍数。可以在任一堆上取若干张纸牌，然后移动。

移牌规则为：在编号为 $1$ 堆上取的纸牌，只能移到编号为 $2$ 的堆上；在编号为 $N$ 的堆上取的纸牌，只能移到编号为 $N-1$ 的堆上；其他堆上取的纸牌，可以移到相邻左边或右边的堆上。

现在要求找出一种移动方法，用最少的移动次数使每堆上纸牌数都一样多。

例如 $N=4$ 时，$4$ 堆纸牌数分别为 $9,8,17,6$。

移动 $3$ 次可达到目的：

- 从第三堆取 $4$ 张牌放到第四堆，此时每堆纸牌数分别为 $9,8,13,10$。
- 从第三堆取 $3$ 张牌放到第二堆，此时每堆纸牌数分别为 $9,11,10,10$。
- 从第二堆取 $1$ 张牌放到第一堆，此时每堆纸牌数分别为  $10,10,10,10$。

**输入格式**

第一行共一个整数 $N$，表示纸牌堆数。  
第二行共 $N$ 个整数 $A_1,A_2,\ldots,A_N$，表示每堆纸牌初始时的纸牌数。

**输出格式**

共一行，即所有堆均达到相等时的最少移动次数。

**输入输出样例 #1**

**输入 #1**

```
4
9 8 17 6
```

**输出 #1**

```
3
```

**说明/提示**

对于 $100\%$ 的数据，$1  \le  N  \le  100$，$1 \le  A_i  \le 10000$。



* 没啥好说的，从左往右传递，多退少补贪心就结束了

```c++
#include<iostream>
#include<algorithm>

using namespace std;

const int N = 110;

int q[N];
int n;

int main(){
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
        scanf("%d",&q[i]);

    int total=0;
    for(int i=1;i<=n;i++)
        total += q[i];

    int avg = total/n;
    int res = 0;
    
    for(int i=1;i<=n-1;i++)
    {
        if(q[i]>avg)
        {
            int mv = q[i] - avg;
            res += 1;
            q[i+1] += mv;
        }
        else if(q[i] < avg)
        {
            int mv = avg -q[i];
            res += 1;
            q[i+1] -= mv;
        }
        else continue;
    }

    printf("%d\n",res);
    return 0;
}
```



### G9) 糖果传递

> 标签： # HAOI 2008  #洛谷 P 2512
