# Virtuoso (ArXiv 2025/03/27)

【Title】Virtuoso: Enabling Fast and Accurate Virtual Memory Research via an Imitation-based Operating System Simulation Methodology

【开源链接】https://github.com/CMU-SAFARI/Virtuoso



## Comments

这篇工作......伟大，无需多言！Best Paper级的工作！神中神的工作。



## Abstract

来自新兴应用的数据需求呈现前所未有的增长，已经使虚拟内存（VM）成为主要的性能瓶颈。随着内存需求的持续上升，VM 的开销预计将长期存在。研究人员正在探索新的硬件/操作系统协同设计方案，以在各种应用和系统中优化虚拟内存。为了评估这些设计，研究人员依赖于多种模拟方法来建模虚拟内存的各个组成部分。然而，现有的模拟工具存在以下问题：

* 要么在建模 VM 的软件组件方面缺乏所需的准确性 
* 要么过于缓慢和复杂，难以对跨越硬件/软件边界的方案进行原型设计与评估。

我们提出了 Virtuoso，这是一个全新的仿真框架，能够快速且精确地对虚拟内存子系统的软件和硬件组件进行原型设计与评估。Virtuoso 的核心理念是引入一个**轻量级的用户空间操作系统内核，称为 MimicOS**，其具备以下特性：

> userspace OS Kernel

* 通过仅模拟所需的内核功能来加速仿真时间
* 通过提供易于使用的高级编程接口，方便开发新的操作系统例程，用于模仿真实的功能
* 在将 Virtuoso 集成到指定的体系结构模拟器后，能够对应用层和系统层中虚拟内存相关的影响进行准确且灵活的评估。

在本研究中，我们将 Virtuoso 集成到五种各具特色的体系结构模拟器中，这些模拟器分别专注于系统设计的不同方面，并在此基础上大量扩展了多种最新的虚拟内存（VM）方案。通过这种方式，我们为研究人员提供了一个共同的平台，用于评估现有的 VM 设计，并开发和测试新的方案。

我们通过评估五种不同的使用场景，展示了 Virtuoso 的灵活性与通用性，并获得了对当前先进 VM 技术的新见解。我们的验证结果表明，当将 Virtuoso 移植到 Sniper（一个先进的微架构模拟器）上时，能够实现以下模拟效果：

* 以 82% 的准确率模拟真实高端服务器级 CPU 的内存管理单元（MMU）
* 以最高 79% 的准确率模拟真实 Linux 内核的缺页中断延迟。

因此，与 Sniper 的基础版本相比，Virtuoso 在模拟真实高端服务器级 CPU 的 IPC 性能方面提高了 21% 的准确率。与此同时，Virtuoso 在四个基础架构模拟器上的平均仿真时间开销仅为 20%。



## Introduction

虚拟内存（VM）是现代计算系统的基石之一，它实现了对物理内存的应用透明管理、隔离与数据共享。当前的应用程序（如 [24–45]）具有多样化的特征，这些特征对虚拟内存子系统提出了不同的挑战。我们将这些工作负载大致分为两类：

* **长时间运行的工作负载**（即执行时间超过数百秒）[24, 28–31, 33–35]，这类工作负载具有庞大的数据占用量和不规则的内存访问模式，通常会带来较高的地址转换开销；
* **短时间运行的工作负载**（即执行时间通常少于 1 秒）[36–45]，其运行时间不足以摊销系统软件操作（如物理内存分配）所带来的开销。

已有多项前沿研究与工业调研工作 [46–57] 表明：

* 在**长时间运行的工作负载**中，地址转换的开销可占总执行时间的 **高达 40%**；
* 在**短时间运行的工作负载**中，内存分配操作的开销则可占到 **高达 95%** 的执行时间。

随着内存需求的不断增长，以及系统向更大的物理地址空间转变（例如通过使用大容量非易失性内存的**混合内存系统** [59–64]，或是**内存分离架构** [65–94]），与虚拟内存操作相关的开销预计将进一步上升。

为应对这些开销，许多研究采用了**硬件/操作系统协同设计（hardware/OS co-design）**的方法，重新审视虚拟内存（VM）的一些核心方面，例如：页表结构 [54, 95–103]、虚拟地址到物理地址的映射机制 [104–111]、物理内存分配策略（如透明大页机制 [112–117]）以及 TLB（快表）的设计 [13, 118–125]。

然而，对这些 VM 设计进行评估并非易事。这一挑战主要源于需要准确建模虚拟内存中操作系统与硬件组件之间的相互作用。例如，在现代系统中，操作系统负责大页的分配，而这直接影响：

* TLB 的命中率和效率 [126–128]；

* 页表（PT）的内存占用；

* 页表遍历的延迟 [97, 98, 103]；

* 缺页异常的处理延迟 [42, 104, 112, 113, 129, 130]。

由于上述复杂的交互机制，若没有一个**全面且健壮的仿真基础设施**，对现有和未来虚拟内存设计的优劣进行有效评估将变得极为困难。

不幸的是，现有的现代仿真器存在以下两类问题：

* **设计目标不同**，例如许多仿真器主要关注于处理器核心的微架构 [131–135]，因此**缺乏对虚拟内存子系统中操作系统组件的建模能力与灵活性**（如 Sniper [133]）；
* **运行速度较慢，开发难度大**，例如 gem5 的全系统（full-system）执行模式 [136]，这严重阻碍了**快速进行设计空间探索**的能力。

这种仿真器的“二元分化”现象造成了该领域中的一个显著空白，迫使研究人员在每项虚拟内存方案的评估中，都需要投入大量时间和精力来开发新的自定义工具或方法论 [54, 101, 108, 127–129, 137–141]。

**现有的仿真方法**。许多仿真器（如 [131–136, 142–145]）主要用于建模和分析 CPU 的微架构特性。这类仿真器通常**只模拟基本的操作系统功能**，并使用简化的方法来估算操作系统相关流程对性能的影响。我们将这类仿真器归类为**基于模拟（Emulation-based）**的仿真器。基于模拟的仿真器往往采用**一阶近似**（例如：固定延迟）来处理操作系统流程和虚拟内存操作。然而，正如我们在第 §2 节中展示的，**使用固定延迟会导致对虚拟内存开销的估算不准确**，因为 VM 开销在不同工作负载和系统状态下表现出高度可变性。因此，这些仿真器**不适合用于评估依赖硬件/操作系统协同设计的新型虚拟内存方案**（而且它们本身也并非为此而设计）。

另一方面，**全系统仿真器**如 gem5 [136] 和 QFlex [146]，支持对整个操作系统进行详细建模，可以实现**真实的内存管理机制**，从而支持对新型虚拟内存架构的评估。然而，这类仿真器也存在显著缺点，包括：

* **仿真速度慢**
* **内存开销高**
* **开发工作量大**

这些缺点**阻碍了基于硬件/操作系统协同设计的新型虚拟内存方案的快速原型开发与评估**。

![](.\virtuoso_p1.png)

正如我们在表 1 中所展示的，本工作的目标是设计一个**仿真框架**，该框架能够：

* 保持基于模拟（emulation-based）仿真器的仿真速度
* 实现与全系统（full-system）仿真器相媲美的准确性
* 使研究人员能够轻松开发和评估新的虚拟内存（VM）方案

为此，我们提出了 **Virtuoso** —— 一个全新的仿真框架，支持对虚拟内存子系统中的**软件和硬件组件进行快速且精确的原型开发和评估**。

Virtuoso 的核心思想是采用一个**轻量级用户态内核（userspace kernel）**，该内核使用高级语言（如 C++ [147]）编写，具备以下优势：

* 研究人员可以**仅隔离所需的内核功能模块**（例如 Transparent Huge Pages [114, 115]），以**加快仿真速度**；
* 即使不是内核开发专家，也可以**轻松开发新的操作系统流程**（例如自定义的物理内存分配器 [112, 113, 117, 129]）；
* 可将 Virtuoso 集成进架构仿真器中，**准确评估操作系统功能在应用层和系统层的性能影响**。

该框架兼具速度、准确性与开发友好性，为探索 VM 软硬件协同设计提供了理想的平台。



我们提出的方法论包括对一个**用户态内核**进行**动态插桩（instrumentation）**，该内核作为**独立程序运行**，并通过两条不同的通道与**架构仿真器**进行通信：一个是**功能通道（functional channel）**，另一个是**指令流通道（instruction stream channel）**。

- **功能通道**利用共享内存原语和专用的 ISA 指令，在内核与仿真器之间交换功能事件（例如中断）的消息。例如，当仿真器触发一次缺页异常时，它会将该事件传递给用户态内核；用户态内核处理该缺页异常，并通过共享内存区域将处理结果反馈给仿真器。
- **指令流通道**则允许用户态内核将动态插桩的指令流（例如缺页处理程序的指令）注入到仿真器中，从而使仿真器能够**准确建模操作系统流程引入的开销**（如额外的延迟、内存干扰等）。

这种设计使得仿真器可以在保持高性能的同时，更真实地反映操作系统功能对系统性能的实际影响。

通过上述方法，我们构建了 **MimicOS** —— 一个用 C++ 编写的轻量级用户态内核 [147]，它**模仿但不限于 Linux 内核的基本内存管理功能** [148]。MimicOS 具有良好的可移植性，并且可以很容易地与架构仿真器的内存模型对接（见 §6.2）。

在本研究中，我们将 MimicOS 集成到了五个架构仿真器中：

> Sniper ChampSim Ramulator2 gem5-SE MQ-Sim

以 MimicOS 和 Sniper 为基础，我们构建了 **VirTool** —— 一个包含软硬件组件的全面工具集，可用于评估多种先进的虚拟内存（VM）机制。通过这一工作，我们的目标是：

* 开启从微架构层面的低级 VM 机制到系统软件层面机制等**广泛的研究用例**；
* 为研究人员提供一个**统一的平台**，以评估现有的 VM 设计，或开发并测试新的 VM 方案。

> **表 2** 对 VirTool 中包含的现有技术进行了全面的总结。

![](.\virtuoso_p2.png)

**验证与比较**。我们将 MimicOS+Sniper 的准确性与一款真实的高端服务器级处理器进行对比验证（见 §7.2），并展示了四个关键结果。

* 首先，MimicOS+Sniper 相较于真实系统，分别以 82% 和 85% 的准确度估计了每千条指令的 L2 TLB 缺失次数和页表遍历延迟。
*  其次，MimicOS+Sniper 相较于在真实机器上运行的 Linux 内核测量的页错误延迟，以 66%（最高可达 79%）的准确度估计了页错误延迟。
*  第三，MimicOS+Sniper 将每周期指令数（IPC）性能估计准确度提高了 21%（从 66% 提高到 80%），而相比基准 Sniper，模拟时间开销为 35%。
*  第四，MimicOS 在四个仿真器中平均只增加了 20% 的模拟时间开销，而启用 gem5 的全系统执行模式相较于 gem5 的系统调用仿真模式，增加了 77% 的模拟时间开销。

**多样性与用例**。为了展示 Virtuoso 的多样性，我们进行五个案例研究，这些研究通常耗时且使用现有仿真工具难以准确且快速评估。

* 首先，我们分析了四种不同页表设计的性能 [54, 97]，并得出了关于它们对页表遍历延迟、次级页错误延迟和主内存干扰的影响的关键见解（见 §7.4）。
*  其次，我们评估了不同物理内存分配策略在大型语言模型推理工作负载中的开销（见 §7.5）。
*  第三，我们对限制虚拟到物理地址映射在物理内存中的架构权衡进行了分析 [105]（见 §7.6.1）。
*  第四，我们评估了基于内存碎片化程度的连续性感知地址翻译 [151] 的好处（见 §7.6.2）。
*  第五，我们分析了在具有不同内存分配模式的工作负载中采用中间地址空间方案 [111] 的影响（见 §7.6.3）。

在本研究中，我们做出了以下贡献：

* 我们提出了Virtuoso，一个新的仿真框架，采用了一种新的基于模仿的操作系统仿真方法。Virtuoso使得虚拟内存（VM）子系统的硬件和软件组件能够快速且准确地进行原型设计和评估。
* 我们将我们的新方法与五个不同的架构仿真器集成，并实现了一套全面的先进虚拟内存（VM）技术，为研究人员提供了一个评估当前和新虚拟内存设计的共同平台。
* 我们将Virtuoso与真实的CPU系统进行了验证，并展示了它在仅略微增加仿真时间的情况下，提高了先进的基于仿真的仿真器的准确性。我们证明了Virtuoso能够弥合基于仿真和全系统仿真器之间的差距，以一种快速且灵活的方式实现虚拟内存设计的准确探索。
* 我们通过进行五个案例研究来展示Virtuoso的多样性，这些案例研究耗时且难以使用现有仿真工具准确且快速地评估。
* Virtuoso的源代码及与所有五个仿真器的集成可以在https://github.com/CMU-SAFARI/Virtuoso 上免费下载。



## Background & Motivation

#### VM Overheads

减少虚拟内存子系统的开销一直是计算机体系结构和操作系统研究中的一个长期挑战。近年来，数据密集型的工作负载[24–35]将虚拟内存开销转变为主要的性能瓶颈。正如多项学术和工业研究[46–57]所示，**地址转换**会显著降低应用程序的性能，最多占总执行时间的40%[50, 51]。与此同时，**负责分配物理内存的操作系统例程**可能会导致高性能开销，最高可达95%[42, 130, 152]。

图1显示了在真实高端服务器级系统中执行的长时间运行（即> 100秒）和短时间运行（即< 1秒）工作负载中，地址转换和物理内存分配所占的总执行时间比例（我们的评估方法在§7.1中有详细描述）。我们做出了两个关键观察。

* 首先，长时间运行的工作负载平均有25%（4.9%）的总执行时间用于地址转换（内存分配）。
* 相比之下，在短时间运行的工作负载中，内存分配的开销占总执行时间的比例较大，即平均为32%，而地址转换的开销非常小，即平均不到1%。

这是因为在长时间运行的工作负载中，物理内存分配的开销随着时间的推移往往会摊销，而在短时间运行的工作负载中则不会。我们得出结论，**虚拟内存子系统的开销会因不同的工作负载而有所不同，并且可能会显著影响性能。**

![](.\virtuoso_p3.png)

新兴应用程序日益数据密集的特性以及向大物理地址空间的过渡[58]（例如，通过计算驱动的内存模块[99, 154–158]、大型混合内存层次结构[59–64]、内存分离[65–94]、具有统一虚拟内存的异构系统[159, 160]）预计将增加虚拟内存子系统引起的开销[51, 70]。



#### Hardware/OS Co-Design

缓解虚拟内存（VM）开销的一种有前景的方法是硬件和操作系统的联合设计。正如多项先前的研究所示，虚拟内存可以通过以下方式进行改进：

* 设计更高效的页表[54, 96, 97, 161, 162]（例如，基于哈希的页表[54, 97, 161]）
* 强制并利用虚拟地址和物理地址之间的连续性，以增加处理器的地址转换范围[46, 50, 113, 128, 129, 151, 163–165]（例如，基于范围的转换[151]），
* 采用基于哈希的虚拟到物理地址映射，以减少用于地址转换的元数据大小[105, 107, 109]，
* 引入中间地址空间[106, 110, 111, 166]，直到进行主存访问时才进行地址转换，
* 采用大型操作系统管理的TLB[118, 167]，以提高TLB命中率，
* 通过将管理虚拟内存子系统的操作系统例程卸载到专用硬件上来加速操作系统例程[42, 130, 152]。



#### Need for Detailed Simulation

由于虚拟内存（VM）开销巨大，必须拥有便捷且快速的方法来原型化和评估现有的以及新的虚拟内存理念和技术。然而，这样的评估是具有挑战性的，因为虚拟内存组件（i）跨越硬件/软件边界，（ii）高度相互依赖。这导致虚拟内存组件在不同工作负载和系统状态下的开销存在显著的变化。例如，TLB的有效性[128, 164]以及由页表引起的存储需求、查找延迟和主存争用都在很大程度上取决于操作系统的物理内存分配器为用户应用程序提供的巨大页面（例如，2MB页面）的数量。同时，物理内存分配策略会影响页故障处理程序的延迟，这可能会极大地影响应用程序的尾延迟。因此，使用简单的一级模型（例如，假设固定延迟的模型）来准确建模虚拟内存组件的开销是具有挑战性的。我们通过两个示例案例展示虚拟内存组件引起的开销变化。



#### Example: Variation of Minor Page Fault Latency

![](.\virtuoso_p4.png)

图2展示了在实际高端服务器系统中执行的所有工作负载下，使用两种操作系统页面分配策略（即启用和禁用透明大页面（THP）[114, 115]）时，轻微页故障（MPF）延迟的分布（§7.1）。我们得出两个关键观察结果。首先，给定单一物理内存分配策略时，MPF的延迟可能会显著变化。在启用THP的情况下，平均MPF延迟为2.2微秒，而标准差大于50微秒。其次，当物理内存分配策略提供大页面时，页故障（PF）延迟的分布可能会发生显著变化。在启用THP的情况下，异常值（即延迟超过10微秒的MPF）对总MPF延迟的贡献为67%，而在禁用THP的情况下，异常值对总PF延迟的贡献为25.5%。先前的研究（例如，[176, 177]）将这种变化归因于页故障处理过程中可能发生的大量不同操作（例如，页面清零、回退机制、大页面分配、页表更新、内存回收）和病态情况。

> 说实话，没太看懂这个图



#### Example: Variation of Page Table Walk (PTW) Latency

![](.\virtuoso_p5.png)

页表遍历（PTW）延迟的变化。图3展示了在实际系统中执行的45个应用程序的平均PTW延迟，这些应用程序在不同级别上对虚拟内存（VM）产生不同压力。我们观察到，PTW延迟在不同应用程序之间存在显著差异。例如，执行大规模I/O分配的应用程序的PTW为39个周期，而来自GraphBig [33]的单源最短路径工作负载（SSSP）的PTW延迟则大于180个周期。



我们得出结论，虚拟内存（VM）子系统的开销在不同的工作负载和系统配置中存在显著差异，因此无法通过一阶近似（例如，假设固定延迟）准确建模，而需要进行详细的仿真。



### Existing Simulation Frameworks

我们将现有的仿真器（例如，[131, 133–136, 143, 146, 149, 168]）分为两大类：（i）仿真操作系统例程的仿真器，和（ii）在硬件仿真器上运行真实完整操作系统的全系统仿真器。不幸的是，正如我们下面所述，这两种类型的仿真器都不适合评估依赖于操作系统例程与硬件支持共同设计的虚拟内存（VM）方案，这妨碍了这种方案的快速和准确的原型设计与评估。表2总结了十一种现有仿真器和我们提出的仿真器Virtuoso所支持的虚拟内存组件。



#### Emulating OS Routines

许多现有的仿真器（例如，[131–136, 142–145]）的设计侧重于准确建模**核心**、**主存**或其他**硬件组件**，这些组件**不直接依赖于或与操作系统**交互。因此，这些仿真器缺乏（而且有些仿真器在其设计的使用场景中不需要）一种准确建模操作系统组件在虚拟内存（VM）子系统中的影响（例如，**延迟、内存干扰**）的方法。例如，一些仿真器（例如，[132, 133, 143]）仅建模应用程序与操作系统例程子集（例如，mmap() [179]）的功能交互，并通常使用一阶近似（例如，Sniper [133] 使用固定的页表步进延迟，Champsim [132] 使用固定的页面错误延迟）来建模虚拟内存开销。然而，正如我们在图2和图3中所展示的，**虚拟内存的开销在不同工作负载和应用程序之间可以显著变化，因此不能通过静态的一阶近似准确建模。**在§7.2中，我们展示了使用固定页表步进延迟的Sniper基准版本相较于真实系统在指令每周期（IPC）估算上产生了35%的误差。因此，这类仿真器不适合评估需要对操作系统内核代码进行修改并增加新硬件支持的新虚拟内存方案。



#### Full-System Simulation

全系统仿真器（例如，[136, 146, 168, 180–183]）如gem5提供的全系统执行模式[136]和基于QEMU的架构仿真器如QFlex[146]，允许在硬件仿真器之上执行完整的操作系统，包括真实的内存管理和其他操作系统例程。这种方法在评估涉及操作系统内核代码修改并需要新硬件支持的虚拟内存设计时特别有价值。然而，现有的全系统仿真方法存在三个主要限制：

* 仿真速度较慢
* 内存开销较高
* 开发时间和精力消耗较大

首先，模拟一个完整的操作系统会大幅增加仿真时间和内存消耗，从而妨碍快速的设计空间探索。模拟每个操作系统例程而无法省略与所需评估无关的例程，可能会显著增加仿真时间。

同时，启动一个完整的操作系统会显著增加每个仿真任务的内存消耗。在§7.3中，我们展示了在gem5 [136] 上模拟一个完整的操作系统，与gem5的系统调用仿真模式（gem5-SE）相比，仿真时间增加了77%，内存消耗增加了1.69倍（从1GB增加到1.69GB）。其次，在全系统仿真器上评估新的硬件/操作系统共同设计方案需要

* 修改本来就很复杂的操作系统内核代码
* 在模拟硬件上进行功能验证
* 扩展仿真器以支持新硬件组件（例如新的TLB设计）
* 操作系统例程与硬件之间的接口进行复杂的修改

这个过程需要大量的开发工作和时间，尤其是对于那些不精通操作系统开发的研究人员。我们得出结论，尽管全系统仿真器是计算机体系结构研究中不可或缺的工具，但它们限制了生产力并带来了高仿真开销，从而妨碍了它们在探索和评估跨越硬件/软件边界的虚拟内存方案中的实际应用。



#### Simulation Requirements

为了准确、高效、快速地评估新的虚拟内存方案，仿真框架需要具备以下功能：（i）支持所需硬件和操作系统修改的快速原型设计，（ii）准确且快速地估算新操作系统和硬件组件带来的开销和效益，（iii）模拟虚拟内存组件与系统其他部分及其相互之间的交互。





## Virtuoso: Overview

我们介绍了Virtuoso，一种新的仿真框架，用于快速且准确地原型化和评估虚拟内存（VM）子系统的软件和硬件组件。Virtuoso的关键理念是采用一个轻量级的用户空间内核，该内核使用高级语言（例如C++）编写，允许研究人员：

* 仅隔离所需内核代码的功能，以加速仿真时间；
* 无需成为内核代码专家，就能使用高级语言轻松开发新的操作系统例程；
* 通过将Virtuoso集成到体系结构仿真器中，准确评估操作系统在应用层和系统层的影响。图4展示了Virtuoso的组件和工作流程的高层次概述。

**Virtuoso由两个主要组件组成：**

* **一个轻量级用户空间内核**，称为MimicOS，它模拟操作系统的虚拟内存子系统；
* 一个MimicOS与Virtuoso所结合的体系结构仿真器之间的**通信通道**。

当体系结构仿真器执行需要操作系统干预的事件（例如，页面错误、内存分配等）时，仿真器通过通信通道将事件转发给MimicOS。MimicOS处理该事件后，Virtuoso执行两个操作。首先，Virtuoso动态地插桩MimicOS的二进制文件，并将MimicOS的反汇编指令注入到仿真器的处理器性能模型中。通过这种方式，仿真器可以准确估算已执行操作系统例程对应用程序性能的影响。其次，当MimicOS解决事件后，它通过功能通道将功能响应返回给体系结构仿真器（例如，向核心发信号重新开始走页表）。

> 不愧是ETH大团队

![](.\virtuoso_p6.png)



## Imitation-Based Simulation Methodology

我们描述了Virtuoso仿真方法的关键组件：（i）轻量级用户空间内核和（ii）内核与体系结构仿真器之间的通信接口，并提供了一个页面错误处理例程仿真流程的逐步示例。



### Lightweight Userspace Kernel

Virtuoso采用轻量级用户空间内核来模拟所需的操作系统内核代码功能。这种设计决策使研究人员能够：（i）仅模拟相关的操作系统例程以加速仿真时间；（ii）快速且轻松地开发新的操作系统模块。

#### Kernel Module Selection

Virtuoso 的内核由不同的模块组成，研究人员可以根据自己的研究需求选择这些模块，以在准确性和仿真时间之间找到平衡。例如，如果研究人员希望快速评估不同页面故障处理机制对系统性能的影响，而不考虑无关的操作系统例程（例如线程调度器），那么内核可能仅包含页面故障处理程序。正如我们在 §7.3 中所展示的，执行与用户空间内核配对的仿真器，该内核忠实地模拟仅 Linux 内存管理子系统的功能，比仿真整个 Linux 内核快 49%。

#### Ease of Development

用户空间内核可以使用高级语言（例如 Python、C++）编写，这使得开发新的操作系统例程变得更加容易，而无需专家知识。例如，研究人员可以轻松地使用高级库（例如 mlpack [184]、TensorFlow [185]、PyTorch [186]）开发一个新的基于机器学习的页面替换算法，并将其与内核集成，而无需理解或修改生产级操作系统的复杂代码。同时，Virtuoso 的模块化设计允许通过增加支持的操作系统模块的数量，来更精确地模拟目标内核的功能，但代价是增加了仿真时间。



### Interface with the Architectural Simulator

为了评估操作系统例程对系统性能的影响，用户空间内核需要在架构模拟器之上执行。为此，Virtuoso

* 将两个进程（即用户空间内核和模拟器）作为独立的应用程序执行
*  在用户空间内核和模拟器之间建立一个新的通信接口，该接口由两个新的通信通道组成，利用同步原语来协调内核和模拟器之间的执行流。



#### Communication Channels

Virtuoso 在内核和模拟器之间建立了两个通信通道：(i) 功能通道和 (ii) 指令流通道。通过功能通道，模拟器将功能请求（例如页面错误请求）传递给内核，内核则将请求的仿真结果返回给模拟器（例如，发出重新启动页表遍历的信号）。然而，功能通道不足以估算操作系统例程对系统性能的影响。例如，架构模拟器仅通过用户空间内核的功能状态（例如新页面的物理地址）无法估算页面错误处理程序对各种系统组件（例如主内存控制器争用）的影响。为了解决这个问题，Virtuoso 使用二进制插桩工具（例如 Intel Pin [187]、DynamoRIO [188]）动态生成内核的指令流（例如页面错误处理程序指令），并通过单独的指令流通道将其传递给模拟器。

同步原语。为了在最大化可移植性的同时实现高仿真速度（即将用户空间内核移植到许多不同的架构模拟器时尽量减少修改），Virtuoso 采用了 (i) 基于 POSIX 的共享内存原语来在内核和架构模拟器之间交换消息，以及 (ii) `magic`操作（例如 gem5 中的 m5ops [136]、Sniper 中的 xchg 指令 [133]）来同步用户空间内核与架构模拟器的执行。



#### Execution Flow

当模拟的应用程序引发中断或系统调用时，架构模拟器执行两个操作：

* 将中断/系统调用的参数写入功能通道（即基于 POSIX 的共享内存段 [190]）
* 通知用户空间内核读取参数并开始处理请求。

在用户空间内核处理请求的同时，二进制插桩工具生成内核代码的指令流，并通过指令流通道将其发送到模拟器。模拟器消费这些指令流，将其输入到核心模型，并估算内核代码对性能的影响。内核指令流的生成和消费是并行进行的，以避免在仿真中产生不必要的延迟。 当用户空间内核解决请求时，它执行两个操作：(i) 将请求的结果写入功能通道，(ii) 执行`magic`指令来通知模拟器继续应用程序的仿真。当模拟器解码`magic`指令时，它暂停用户空间内核指令的插桩，并切换回模拟的应用程序。



### Multithreaded Userspace Kernel

Virtuoso 的用户空间内核支持多线程，可以同时处理来自不同进程的多个系统调用或中断。为了实现这一点，当模拟器上执行的应用程序向内核发出请求时，内核会创建一个新线程来处理该请求，或将请求转发给一个可用的线程。内核使用同步原语来保证多线程环境中内核例程的正确性，并模拟原子操作的性能开销。例如，如果多个应用程序竞争物理内存资源，我们的方法可以捕获相应的同步开销。



### Simulation Flow: Page Fault Handling Example

![](.\virtuoso_p7.png)

图 5 展示了所提出的仿真方法的工作流程，并以页面错误（PF）处理程序为例进行案例研究。首先，内核和模拟器作为用户空间进程启动。在这个例子中，内核包含一个页面错误处理程序，该处理程序由多个不同的模块 {**1**}（例如，页面表管理、页面缓存 [193] 管理等）。模拟应用程序被送入模拟器的前端（即指令格式生成器）（例如，基于跟踪、基于仪器、基于仿真等）以生成指令流 {**2**}。如果指令包含加载或存储内存操作数，前端将发出内存访问请求到模拟器的核心模型{**3**}。核心模型将内存请求转发到内存管理单元（MMU）模型进行地址转换 {**4**}。如果 MMU 在 TLB 层次结构中没有找到转换，它将触发页面表（PT）遍历 {**5**}。在这种情况下，PT 遍历器没有在 PT 中找到转换并触发页面错误(PF) {**6**}。通过功能通道 A，模拟器向内核发送请求以处理 PF {**7**}。内核解码消息并执行 PF 处理程序代码 {**8**}。PF 处理程序代码使用二进制插桩工具（例如，Intel Pin [187]，DynamoRIO [188]）进行插桩 {**9**}，插桩后的反汇编指令流通过指令流通道 B 发送到模拟器。

PF 处理程序的指令流被转发 {**10**} 到模拟器的核心模型，模拟器模拟内核指令的执行，以估算 PF 处理程序对微架构状态和性能的影响（例如，主存竞争、缓存污染） {**11**}。当 PF 处理程序执行完成后，内核将 PF 的结果（例如，新页面的物理地址和页面大小）传递给模拟器 {**12**}。然后，模拟器重新遍历页面表，核心模型将 PF 的延迟加到翻译延迟上 {**13**}，并将物理地址转发到内存层次结构。



## MimicOS: A Lightweight Userspace Kernel for Memory Management

使用我们新的模仿基础的仿真方法论（§4），我们构建了MimicOS，一个新的轻量级内核，使用C++编写，模仿但不限于Linux内核 [148] 在x86-64系统 [194] 上的基本内存管理功能。



## Mimicking Linux Memory Management

