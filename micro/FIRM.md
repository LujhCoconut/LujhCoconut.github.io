# FIRM (MICRO'14)

**[Title]** FIRM: Fair and High-Performance Memory Control for Persistent Memory Systems

* **论文速览系列**

年份比较早，这篇文章分析不追求过多细节，直接速通



## Abstract 

* 直接翻译

字节寻址非易失性内存（NVM）带来了新的技术——持久性内存。它结合了传统主存储器的字节寻址和高速接口的优点，以及传统存储的持久性。为了支持数据的持久性，持久性内存系统需要对写请求进行复杂的数据复制和排序控制。因此，如本文所示，操作持久性内存的应用（持久性应用）与传统（非持久性）应用相比，具有非常不同的内存访问特性。持久性应用在内存通道上对连续的内存区域产生大量写入流量，而通道无法同时服务读写请求，导致由于低bank并行度、频繁的写队列清空以及读写间频繁的总线切换而使内存带宽利用率降低。这些特性削弱了传统内存调度方案在非持久性应用中提供的高性能和公平性。

本文的目标是为运行持久性和非持久性应用的持久性内存系统设计一种公平且高性能的内存控制方案。我们的方案FIRM包含三个关键思想。首先，FIRM将请求源分类为非密集型、流式、随机和持久性，并为每类请求源生成请求批次。其次，FIRM跨多个内存bank分散持久性内存的更新，以提高bank级并行度，从而提升持久性内存访问的带宽利用率。第三，FIRM以减少总线切换和写队列清空的方式调度来自不同源的读写请求批次。我们的详细评估显示，与五种已有的内存调度器设计相比，FIRM显著提升了系统性能和公平性。



## Introduction

> 论文速览采用AI翻译，略作解释，部分名词有误，未作修正，意会即可。请注意文章年份为**2014**年！

几十年来，计算机系统采用了两级存储模型，包括：

* 快速的、字节寻址的主存储器，用于临时存储应用程序的工作集数据，但在系统停止、重启或崩溃时数据会丢失；

* 缓慢的、块寻址的存储设备，用于永久存储可跨系统启动或崩溃的持久性数据。

最近，这种传统的存储模型得到了持久性内存技术的拓展——一种介于传统主存储器和存储设备之间的新层级，结合了两者的特性【2, 9, 47, 54, 59】。持久性内存允许应用程序像访问传统主存一样，通过加载和存储操作来操控持久数据。然而，持久性内存是持久数据的永久存储地，借鉴数据库和文件系统中的技术，通过版本控制（例如日志记录和影子更新）【17, 54, 88, 90】和写顺序控制【17, 54, 66】来保证数据一致性，如同数据存储在传统存储设备（如硬盘或闪存）中。

通过在主存中实现数据持久性，应用程序可以直接通过快速内存接口访问持久数据，而无需在缓慢的存储设备中进行数据块的调页或因页面错误而进行上下文切换。因此，持久性内存可以显著提升对高可靠性需求的应用（如数据库和文件系统）的性能，并支持设计出在高性能下更可靠的系统。正因如此，持久性内存近期引起了学术界和工业界的广泛关注【1, 2, 16, 17, 37, 54, 60, 66, 70, 71, 88, 90】。最近的研究【54, 92】甚至展示了具有接近无持久性支持的系统性能的持久性内存系统。

多种类型的物理设备可以用来构建持久性内存，只要它们对应用程序表现为字节寻址和非易失性即可。此类字节寻址非易失性内存（BA-NVM）的示例包括自旋转移矩（STTMRAM）【31, 93】、相变存储器（PCM）【75, 81】、电阻式随机存取存储器（ReRAM）【14, 21】、带电池的DRAM【13, 18, 28】以及非易失性双列直插存储模块（NV-DIMM）【89】等。由于持久性内存尚处于开发的早期阶段，它尤其适用于那些只需对应用程序、系统软件和硬件进行较少或轻量级更改即可从降低存储（或持久数据）访问延迟中受益的应用【10】。此类应用包括数据库【90】、文件系统【1, 17】、键值存储【16】和持久文件缓存【8, 10】。

虽然其他类型的应用可能无法直接从持久性内存中受益，但仍可将BA-NVM用作工作内存（即非持久性主存）来利用其大容量和低待机功耗的优势【45, 73】。例如，近年来大量研究试图将BA-NVM融入传统的两级存储模型中的主存部分【22, 23, 33, 45, 46, 57, 72, 73, 74, 91, 94】。一些最新研究【38, 52, 59】设想BA-NVM可以同时作为持久性内存和工作内存使用。在本文中，我们将利用BA-NVM操作持久性数据的应用称为持久性应用，而将仅将BA-NVM作为工作内存的应用称为非持久性应用。

大多数已有研究专注于设计内存系统以适应持久性应用或非持久性应用中的一种。然而，鲜有关注这两类应用在同一系统中并发运行的情况。

**持久性应用要求内存系统支持崩溃一致性（crash consistency）或持久性特性**，这通常在传统存储系统中得到支持。该特性保证在系统或应用崩溃后，系统数据保持一致状态，通过确保持久性内存更新的谨慎执行，使得未完成的更新可以恢复。实现这一点需要数据复制以及对写入内存顺序的严格控制（详见2.2节）。这些支持持久性的复杂设计赋予了持久性应用新的内存访问特性。具体而言，我们发现这些应用在内存中的持久性数据流式写入频繁，导致了**极高的写入密集度和极低的内存bank并行性**（详见3.1节）。这些特性导致在**并发运行持久性和非持久性应用的系统中，共享内存接口上的读写资源竞争加剧，不公平地拖慢了一类或两类应用的速度**。先前仅为非持久性应用设计的内存调度方案在这种新情境下效率低下且性能不佳（详见3.2节）。我们发现这是因为持久性应用的高写入密集度和低bank并行性导致了三个主要问题，而这些问题无法通过以往的方案有效解决：

* 1）在内存控制器中频繁的写队列排空；

* 2）读写操作间频繁的总线切换，二者均导致内存总线上周期的浪费；

> 在内存控制器中，读写操作需要共享同一条总线或接口，但由于它们的操作方向不同，内存总线在执行读取和写入请求时必须进行切换。每次切换都伴随一定的开销，例如信号稳定时间、方向控制调整等。这些操作会占用总线传输时间，导致在切换过程中无法有效传输数据，进而造成总线利用率下降。

* 3）写入内存期间由于低bank并行性造成的低内存带宽利用率，导致内存读操作长时间延迟（详见第3节）。

我们的目标是设计一种内存控制方案，在同时运行持久性应用和非持久性应用的系统中，**实现公平的内存访问和高系统吞吐量**。我们提出了FIRM，一个公平且高性能的内存控制方案，它通过以下方式实现目标：

* 1）提高持久性应用的带宽利用率；
* 2）平衡持久性和非持久性应用之间的带宽使用。FIRM通过三个组件来实现这一目标。

首先，它将内存请求源分类为非密集型、流式、随机和持久性，以确保不同来源的请求得到公平处理，并以保持行缓冲区局部性的方式为每个源形成请求批次。其次，FIRM将持久性内存更新跨多个存储银行分配，从而提高银行级并行性，进而提高持久性内存访问的带宽利用率。第三，FIRM按最小化总线切换和写队列排空的方式调度来自不同来源的读写请求批次。与五个先前的内存调度器设计相比，FIRM显著提高了系统性能和公平性。本文的贡献如下：

* 我们识别出在持久性和非持久性应用同时访问内存时，与共享内存接口资源竞争相关的新问题。由持久性应用的内存访问特性引起的关键问题是：1）频繁的写队列排空；2）由于高写强度而导致的频繁总线切换；3）由于低写并行性而导致的内存带宽利用率不足。我们描述了先前的内存调度设计在解决这些问题时的无效性。（第3节）

* 我们提出了一种新的跨行写入机制，以提高持久性内存更新的银行级并行性。该技术提高了内存写入的带宽利用率，并减少了非持久性应用读请求的停顿时间。（第4.3节）

* 我们提出了一种新的持久性感知内存调度策略，用于持久性和非持久性应用之间的读写请求，以最小化内存干扰并减少不公平的应用程序减速。该技术通过减少总线切换和写队列排空，减少了在读写之间切换内存总线的开销。（第4.4节）

* 我们全面比较了我们提出的持久性内存控制机制FIRM与五个先前的内存调度器在各种工作负载和系统配置下的性能和公平性。我们的结果显示：1）FIRM在所有评估的工作负载上平均提供了最高的系统性能和公平性；2）FIRM的优势在不同的系统配置下都非常稳定；3）FIRM最小化了先前调度器设计中的总线切换开销。（第7节）



## Background

在本节中，我们将介绍现有的内存调度方案、持久性内存的原理与机制，以及持久性应用生成的内存请求。

### Conventional Memory Scheduling Mechanisms

内存控制器使用内存请求缓冲区，这些缓冲区**在物理上或逻辑上分为读队列和写队列**，用于存储等待调度的内存请求。它还利用**内存调度器**来决定下一个应该调度哪个内存请求。大量的前期研究开发了各种内存调度策略 [7, 26, 27, 34, 41, 42, 48, 49, 61, 62, 63, 64, 65, 67, 76, 77, 84, 85, 95]。传统的商用系统采用了一种变体的“先到先服务”（FR-FCFS）调度策略 [76, 77, 95]，**该策略优先调度行缓冲命中（row-buffer hits）的内存请求，其次是较老的内存请求。**由于这一点，它**可能不公平地降低那些row buffer命中率低且内存需求不高的应用程序的优先级**，进而影响公平性和整体系统吞吐量 [61, 64]。一些设计 [41, 42, 63, 64, 65, 67, 84, 85] 旨在提高系统性能、公平性或二者兼顾。PAR-BS [65] 通过**基于请求到达时间**将来自不同应用程序的请求进行**批处理**，并优先调度最旧的批次，从而实现公平性和防止饥饿现象。它还通过使用**基于排名的应用程序调度来保持每个应用程序的bank级并行性**，从而提高系统吞吐量。ATLAS [41] 通过优先调度获得**最少内存服务**的应用程序来提高系统吞吐量。然而，由于其在内存密集型应用程序之间采用严格的排名，它可能会**不公平地降低内存密集型应用程序的优先级**，导致其运行变慢 [41, 42]。为了解决这个问题，TCM [42] 动态地将应用程序分为低内存强度和高内存强度两类，并在这两类之间采用不同的调度策略，以优化系统吞吐量和公平性。TCM 将低内存强度的应用程序优先于其他应用程序，从而提高系统吞吐量，并在高内存强度应用程序之间重新排列线程排名，提高公平性和系统吞吐量。尽管这些策略在仅执行非持久性应用程序的系统中效果显著，但遗憾的是，这些调度方案没有解决并发运行持久性和非持久性应用程序时所带来的内存请求调度挑战，正如我们在第3节中讨论并在第7.3节中详细评估的那样。



### Persistent Memory

大多数持久性应用程序来源于传统存储系统工作负载（如数据库和文件系统），这些应用程序需要持久内存 [1, 2, 16, 17, 88, 90, 92] 来支持崩溃一致性 [6]，即持久性属性。持久性属性保证了在发生断电或程序崩溃时，存储在非易失性设备中的关键数据（如数据库记录、文件及其对应的元数据）能够保持一致状态，即使在易失性设备中的所有数据可能丢失。在BA-NVM中实现持久性并非易事，因为存在易失性的处理器缓存以及写回缓存和内存控制器进行的内存写入重排序。例如，当持久性应用程序将一个节点插入到存储在BA-NVM中的链表时，可能会发生断电。处理器缓存和内存控制器可能会重排序写请求，先将指针写入BA-NVM，再写入新节点的值。如果由于断电导致新节点的值保留在处理器缓存中丢失，链表就会出现不一致，指针悬挂，从而可能导致不可恢复的数据损坏。为了避免这种不一致问题，大多数持久性内存设计借鉴了数据库和文件系统中的ACID（原子性、一致性、隔离性和持久性）概念 [17, 54, 88, 90, 92]。正如下面所解释的，执行这些概念会导致额外的内存请求，从而影响持久性应用程序的内存访问行为。

**Versioning and Write Ordering**

虽然BA-NVM的非易失性特性可以保证持久性，但原子性和一致性则通过存储相同数据的多个版本并仔细控制写入持久内存的顺序来实现（有关详细信息，请参阅之前的研究 [17, 54, 88, 90, 92]）。图1展示了一个持久树数据结构作为示例，说明了维护版本和排序的不同方法。假设节点N3和N4被更新。我们讨论两种常用的维护多个版本和排序的方法。第一种方法是重做日志 [16, 90]。在这种方法中，两个节点的新值及其地址在更新它们的原始位置之前被写入日志（logN′3 和 logN′4）（见图1(a)）。如果系统在日志记录完成之前失去电源，持久内存可以始终通过使用内存中的完整原始数据进行恢复。写入日志和更新原始位置之间使用了内存屏障。通过这种排序控制，日志中保留足够的信息，确保即使系统在更新所有原始位置之前崩溃，仍能恢复到一致的状态。第二种方法，如图1(b)所示，是影像更新（写时复制）[17, 88]。这种方法不是存储日志，而是分配一个临时数据缓冲区来存储节点的新值（影像副本）。需要注意的是，父节点N1也被影像复制，新指针N′1指向影像副本N′3和N′4。排序控制（如图1(b)中的内存屏障所示）确保在持久内存中写入影像副本完成之前，根指针不会更新。

<img src=".\firm-1.png" style="zoom: 80%;" />

**Relaxed Persistence**

严格的持久性 [53, 54, 70] 要求保持每个写请求的程序顺序，即使是在单次日志更新中。Pelley 等人最近提出了一种放宽持久性模型，以最小化排序控制，仅缓冲和合并对同一数据的写入 [70]。我们的设计采用了他们的放宽持久性模型。例如，我们只强制执行对影像副本和根指针的写入顺序，如图1(b)所示。另一项最近的工作，Kiln [92]，放宽了版本控制，消除了使用日志或影像更新，通过实现一个非易失性最后级缓存（NV Cache）。然而，由于NV Cache的容量和关联度有限，这种设计无法高效地支持数据库和文件系统应用中的大粒度持久更新。因此，我们预见到，在不久的将来，日志记录、影像更新和类似Kiln的设计将在持久内存设计中共存。



**Memory Requests of Persistent Applications**

* Persistent Writes

我们将执行需要持久化的关键数据更新（包括对原始数据位置的更新、日志更新和影像副本更新）定义为持久写入。每个关键数据更新可能会生成任意数量的持久写入，具体取决于更新的粒度。例如，在一个键值存储中，更新可能是添加一个新的值，大小可能是几个字节、几个千字节、几个兆字节或更大。需要注意的是，持久内存架构通常在内存屏障处将持久写入（即脏块）刷新出处理器缓存，或者将持久写入实现为不可缓存（UC）写入 [54, 88, 90, 92]。

* Non-persistent Writes

非关键数据，例如堆栈和数据缓冲区，不需要在系统故障时保持持久性。通常，持久内存不需要对这些写入执行版本控制或排序控制。因此，持久应用不仅执行持久写入，还会执行非持久写入。

* Reads

持久应用还会读取正在进行的持久写入和其他独立读取。持久内存可以放宽独立读取的排序，而不会违反持久性要求。然而，这样做可能会带来显著的性能损失（第3.2节）。对正在进行的持久更新的读取需要等待这些持久写入到达BA-NVM。传统的内存控制器设计通过从写缓冲区服务正在进行的写入来提供读-写顺序。在易失性内存中，这种行为不会影响内存一致性。然而，在非易失性内存中，电源故障或程序崩溃可能会在持久写入写入持久内存之前摧毁正在进行的持久写入。对正在进行的持久更新的投机性读取可能会导致错误的排序，并可能导致不一致，因为如果读取已经得到了一个正在进行的写入的值，而该写入在崩溃时消失，那么错误的数据最终可能会传播到持久内存中。



## MOTIVATION:HANDLING PERSISTENT MEMORY ACCESSES