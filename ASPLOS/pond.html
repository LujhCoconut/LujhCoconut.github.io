<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>

<link href='https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css' /><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; --title-bar-height: 20px; }
.mac-os-11 { --title-bar-height: 28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
h1, h2, h3, h4, h5 { white-space: pre-wrap; }
body { margin: 0px; padding: 0px; height: auto; inset: 0px; font-size: 1rem; line-height: 1.42857; overflow-x: hidden; background: inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; overflow-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) {
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; image-orientation: from-image; }
button, input, select, textarea { color: inherit; font: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.7); color: rgb(85, 85, 85); border-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
thead, tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right: 0px; background-color: inherit; }
.CodeMirror-linenumber { user-select: none; }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background: inherit; position: relative !important; }
.md-fences-adv-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
svg { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; background: 0px 0px; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; -webkit-tap-highlight-color: transparent; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print {
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid; break-before: avoid; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; border-color: transparent !important; padding-top: 0px !important; padding-bottom: 0px !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
  #write > p:nth-child(1) { margin-top: 0px; }
  .typora-export-show-outline .typora-export-sidebar { display: none; }
  figure { overflow-x: visible; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background: rgb(204, 204, 204); display: block; overflow-x: hidden; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) {
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.reversefootnote { font-family: ui-monospace, sans-serif; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.6; font-family: var(--monospace); }
code { text-align: left; vertical-align: initial; }
a.md-print-anchor { white-space: pre !important; border-width: initial !important; border-style: none !important; border-color: initial !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; background: 0px 0px !important; text-decoration: initial !important; text-shadow: initial !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background: rgb(255, 255, 0); color: rgb(0, 0, 0); }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
.md-expand mark .md-meta { opacity: 0.3 !important; }
mark .md-meta { color: rgb(0, 0, 0); }
@media print {
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-fences.md-fences-math { font-size: 1em; }
.md-fences-advanced:not(.md-focus) { padding: 0px; white-space: nowrap; border: 0px; }
.md-fences-advanced:not(.md-focus) { background: inherit; }
.typora-export-show-outline .typora-export-content { max-width: 1440px; margin: auto; display: flex; flex-direction: row; }
.typora-export-sidebar { width: 300px; font-size: 0.8rem; margin-top: 80px; margin-right: 18px; }
.typora-export-show-outline #write { --webkit-flex: 2; flex: 2 1 0%; }
.typora-export-sidebar .outline-content { position: fixed; top: 0px; max-height: 100%; overflow: hidden auto; padding-bottom: 30px; padding-top: 60px; width: 300px; }
@media screen and (max-width: 1024px) {
  .typora-export-sidebar, .typora-export-sidebar .outline-content { width: 240px; }
}
@media screen and (max-width: 800px) {
  .typora-export-sidebar { display: none; }
}
.outline-content li, .outline-content ul { margin-left: 0px; margin-right: 0px; padding-left: 0px; padding-right: 0px; list-style: none; overflow-wrap: anywhere; }
.outline-content ul { margin-top: 0px; margin-bottom: 0px; }
.outline-content strong { font-weight: 400; }
.outline-expander { width: 1rem; height: 1.42857rem; position: relative; display: table-cell; vertical-align: middle; cursor: pointer; padding-left: 4px; }
.outline-expander::before { content: ""; position: relative; font-family: Ionicons; display: inline-block; font-size: 8px; vertical-align: middle; }
.outline-item { padding-top: 3px; padding-bottom: 3px; cursor: pointer; }
.outline-expander:hover::before { content: ""; }
.outline-h1 > .outline-item { padding-left: 0px; }
.outline-h2 > .outline-item { padding-left: 1em; }
.outline-h3 > .outline-item { padding-left: 2em; }
.outline-h4 > .outline-item { padding-left: 3em; }
.outline-h5 > .outline-item { padding-left: 4em; }
.outline-h6 > .outline-item { padding-left: 5em; }
.outline-label { cursor: pointer; display: table-cell; vertical-align: middle; text-decoration: none; color: inherit; }
.outline-label:hover { text-decoration: underline; }
.outline-item:hover { border-color: rgb(245, 245, 245); background-color: var(--item-hover-bg-color); }
.outline-item:hover { margin-left: -28px; margin-right: -28px; border-left: 28px solid transparent; border-right: 28px solid transparent; }
.outline-item-single .outline-expander::before, .outline-item-single .outline-expander:hover::before { display: none; }
.outline-item-open > .outline-item > .outline-expander::before { content: ""; }
.outline-children { display: none; }
.info-panel-tab-wrapper { display: none; }
.outline-item-open > .outline-children { display: block; }
.typora-export .outline-item { padding-top: 1px; padding-bottom: 1px; }
.typora-export .outline-item:hover { margin-right: -8px; border-right: 8px solid transparent; }
.typora-export .outline-expander::before { content: "+"; font-family: inherit; top: -1px; }
.typora-export .outline-expander:hover::before, .typora-export .outline-item-open > .outline-item > .outline-expander::before { content: "−"; }
.typora-export-collapse-outline .outline-children { display: none; }
.typora-export-collapse-outline .outline-item-open > .outline-children, .typora-export-no-collapse-outline .outline-children { display: block; }
.typora-export-no-collapse-outline .outline-expander::before { content: "" !important; }
.typora-export-show-outline .outline-item-active > .outline-item .outline-label { font-weight: 700; }
.md-inline-math-container mjx-container { zoom: 0.95; }
mjx-container { break-inside: avoid; }
.md-alert.md-alert-note { border-left-color: rgb(9, 105, 218); }
.md-alert.md-alert-important { border-left-color: rgb(130, 80, 223); }
.md-alert.md-alert-warning { border-left-color: rgb(154, 103, 0); }
.md-alert.md-alert-tip { border-left-color: rgb(31, 136, 61); }
.md-alert.md-alert-caution { border-left-color: rgb(207, 34, 46); }
.md-alert { padding: 0px 1em; margin-bottom: 16px; color: inherit; border-left: 0.25em solid rgb(0, 0, 0); }
.md-alert-text-note { color: rgb(9, 105, 218); }
.md-alert-text-important { color: rgb(130, 80, 223); }
.md-alert-text-warning { color: rgb(154, 103, 0); }
.md-alert-text-tip { color: rgb(31, 136, 61); }
.md-alert-text-caution { color: rgb(207, 34, 46); }
.md-alert-text { font-size: 0.9rem; font-weight: 700; }
.md-alert-text svg { fill: currentcolor; position: relative; top: 0.125em; margin-right: 1ch; overflow: visible; }
.md-alert-text-container::after { content: attr(data-text); text-transform: capitalize; pointer-events: none; margin-right: 1ch; }


:root {
    --side-bar-bg-color: #fafafa;
    --control-text-color: #777;
}

@include-when-export url(https://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext);

/* open-sans-regular - latin-ext_latin */
  /* open-sans-italic - latin-ext_latin */
    /* open-sans-700 - latin-ext_latin */
    /* open-sans-700italic - latin-ext_latin */
  html {
    font-size: 16px;
    -webkit-font-smoothing: antialiased;
}

body {
    font-family: "Open Sans","Clear Sans", "Helvetica Neue", Helvetica, Arial, 'Segoe UI Emoji', sans-serif;
    color: rgb(51, 51, 51);
    line-height: 1.6;
}

#write {
    max-width: 860px;
  	margin: 0 auto;
  	padding: 30px;
    padding-bottom: 100px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1024px;
	}
}

@media only screen and (min-width: 1800px) {
	#write {
		max-width: 1200px;
	}
}

#write > ul:first-child,
#write > ol:first-child{
    margin-top: 30px;
}

a {
    color: #4183C4;
}
h1,
h2,
h3,
h4,
h5,
h6 {
    position: relative;
    margin-top: 1rem;
    margin-bottom: 1rem;
    font-weight: bold;
    line-height: 1.4;
    cursor: text;
}
h1:hover a.anchor,
h2:hover a.anchor,
h3:hover a.anchor,
h4:hover a.anchor,
h5:hover a.anchor,
h6:hover a.anchor {
    text-decoration: none;
}
h1 tt,
h1 code {
    font-size: inherit;
}
h2 tt,
h2 code {
    font-size: inherit;
}
h3 tt,
h3 code {
    font-size: inherit;
}
h4 tt,
h4 code {
    font-size: inherit;
}
h5 tt,
h5 code {
    font-size: inherit;
}
h6 tt,
h6 code {
    font-size: inherit;
}
h1 {
    font-size: 2.25em;
    line-height: 1.2;
    border-bottom: 1px solid #eee;
}
h2 {
    font-size: 1.75em;
    line-height: 1.225;
    border-bottom: 1px solid #eee;
}

/*@media print {
    .typora-export h1,
    .typora-export h2 {
        border-bottom: none;
        padding-bottom: initial;
    }

    .typora-export h1::after,
    .typora-export h2::after {
        content: "";
        display: block;
        height: 100px;
        margin-top: -96px;
        border-top: 1px solid #eee;
    }
}*/

h3 {
    font-size: 1.5em;
    line-height: 1.43;
}
h4 {
    font-size: 1.25em;
}
h5 {
    font-size: 1em;
}
h6 {
   font-size: 1em;
    color: #777;
}
p,
blockquote,
ul,
ol,
dl,
table{
    margin: 0.8em 0;
}
li>ol,
li>ul {
    margin: 0 0;
}
hr {
    height: 2px;
    padding: 0;
    margin: 16px 0;
    background-color: #e7e7e7;
    border: 0 none;
    overflow: hidden;
    box-sizing: content-box;
}

li p.first {
    display: inline-block;
}
ul,
ol {
    padding-left: 30px;
}
ul:first-child,
ol:first-child {
    margin-top: 0;
}
ul:last-child,
ol:last-child {
    margin-bottom: 0;
}
blockquote {
    border-left: 4px solid #dfe2e5;
    padding: 0 15px;
    color: #777777;
}
blockquote blockquote {
    padding-right: 0;
}
table {
    padding: 0;
    word-break: initial;
}
table tr {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 0;
}
table tr:nth-child(2n),
thead {
    background-color: #f8f8f8;
}
table th {
    font-weight: bold;
    border: 1px solid #dfe2e5;
    border-bottom: 0;
    margin: 0;
    padding: 6px 13px;
}
table td {
    border: 1px solid #dfe2e5;
    margin: 0;
    padding: 6px 13px;
}
table th:first-child,
table td:first-child {
    margin-top: 0;
}
table th:last-child,
table td:last-child {
    margin-bottom: 0;
}

.CodeMirror-lines {
    padding-left: 4px;
}

.code-tooltip {
    box-shadow: 0 1px 1px 0 rgba(0,28,36,.3);
    border-top: 1px solid #eef2f2;
}

.md-fences,
code,
tt {
    border: 1px solid #e7eaed;
    background-color: #f8f8f8;
    border-radius: 3px;
    padding: 0;
    padding: 2px 4px 0px 4px;
    font-size: 0.9em;
}

code {
    background-color: #f3f4f4;
    padding: 0 2px 0 2px;
}

.md-fences {
    margin-bottom: 15px;
    margin-top: 15px;
    padding-top: 8px;
    padding-bottom: 6px;
}


.md-task-list-item > input {
  margin-left: -1.3em;
}

@media print {
    html {
        font-size: 13px;
    }
    pre {
        page-break-inside: avoid;
        word-wrap: break-word;
    }
}

.md-fences {
	background-color: #f8f8f8;
}
#write pre.md-meta-block {
	padding: 1rem;
    font-size: 85%;
    line-height: 1.45;
    background-color: #f7f7f7;
    border: 0;
    border-radius: 3px;
    color: #777777;
    margin-top: 0 !important;
}

.mathjax-block>.code-tooltip {
	bottom: .375rem;
}

.md-mathjax-midline {
    background: #fafafa;
}

#write>h3.md-focus:before{
	left: -1.5625rem;
	top: .375rem;
}
#write>h4.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h5.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
#write>h6.md-focus:before{
	left: -1.5625rem;
	top: .285714286rem;
}
.md-image>.md-meta {
    /*border: 1px solid #ddd;*/
    border-radius: 3px;
    padding: 2px 0px 0px 4px;
    font-size: 0.9em;
    color: inherit;
}

.md-tag {
    color: #a7a7a7;
    opacity: 1;
}

.md-toc { 
    margin-top:20px;
    padding-bottom:20px;
}

.sidebar-tabs {
    border-bottom: none;
}

#typora-quick-open {
    border: 1px solid #ddd;
    background-color: #f8f8f8;
}

#typora-quick-open-item {
    background-color: #FAFAFA;
    border-color: #FEFEFE #e5e5e5 #e5e5e5 #eee;
    border-style: solid;
    border-width: 1px;
}

/** focus mode */
.on-focus-mode blockquote {
    border-left-color: rgba(85, 85, 85, 0.12);
}

header, .context-menu, .megamenu-content, footer{
    font-family: "Segoe UI", "Arial", sans-serif;
}

.file-node-content:hover .file-node-icon,
.file-node-content:hover .file-node-open-state{
    visibility: visible;
}

.mac-seamless-mode #typora-sidebar {
    background-color: #fafafa;
    background-color: var(--side-bar-bg-color);
}

.mac-os #write{
    caret-color: AccentColor;
}

.md-lang {
    color: #b4654d;
}

/*.html-for-mac {
    --item-hover-bg-color: #E6F0FE;
}*/

#md-notification .btn {
    border: 0;
}

.dropdown-menu .divider {
    border-color: #e5e5e5;
    opacity: 0.4;
}

.ty-preferences .window-content {
    background-color: #fafafa;
}

.ty-preferences .nav-group-item.active {
    color: white;
    background: #999;
}

.menu-item-container a.menu-style-btn {
    background-color: #f5f8fa;
    background-image: linear-gradient( 180deg , hsla(0, 0%, 100%, 0.8), hsla(0, 0%, 100%, 0)); 
}



</style>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="http://yandex.st/highlightjs/6.2/highlight.min.js"></script>
<script>
    hljs.initHighlightingOnLoad();
</script>
<style type="text/css">
		#category a{
			text-decoration: none; 
			color: black;
		}
		/* #category {line-height: 2em;} */
		.newh{
			padding-top: 0.5em;
			padding-bottom: 0.5em;
		}
		.newh:hover{
			background: #E6F0FE;
		}
    @media (max-width: 1200px) {
        .book-body {
            /* padding-left: 200px; */
            padding-right: 0px;
        }
    }

    @media (max-width: 1200px) {
        .book-body {
            /* padding-left: 200px; */
            padding-right: 0px;
        }
    }

    @media (max-width: 1200px) {
        .book-body {
            /* padding-left: 300px; */
            padding-left: 0px;
        }
    }

    @media (max-width: 700px) {
        .book-body {
            padding-left: 0px;
        }
    }

    @media (min-width: 600px) {
        #category {
            /* 绝对定位 */
            position: fixed;
            /* 目录显示的位置 */
						float: left;
						margin-right: 2em;
            /* right: 0px; */
            top: 0;
            /* 目录栏的高度,这里设置为60%主要是为了不挡住返回顶部和折叠按钮 */
            height: 93%;
            /* 设置边框这样和正文对比比较明显 */
            border: 0 solid #eaeaea;
            /* 开启垂直滚动条 */
            overflow-y: scroll;
						width:25%;
						display:block;
						/* z-index: 99;; */
						background: white;
						
        }

        /* 正文的样式 */
        #write {
            width:100%;
            display: block;
						/* float:right; */
        }
        img{
        	display: block;
        }
				
        code,tt{
            color:#c7254e;
            background-color:#f9f2f4;
        }
				
        /* 返回顶部按钮样式 */
        #topButton {
            position: fixed;
            float: right;
            right: 10px;
            top: 95%;
						z-index: 99;
        }

        /* 展开或者折叠 */
        #foldOrUnfold {
            position: fixed;
            float: right;
            right: 10px;
            top: 89%;
						z-index: 99;
        }
    }

    @media (-webkit-max-device-pixel-ratio: 1) {
        ::-webkit-scrollbar-track-piece {
            background-color: #FFF
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px
        }

        ::-webkit-scrollbar-thumb {
            background-color: #c2c2c2;
            background-clip: padding-box;
            min-height: 28px
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: #A0A0A0
        }
    }
		@media (max-width: 400px) {
			#category {
					/* 绝对定位 */
					position: fixed;
					/* 目录显示的位置 */
					float: left;
					/* right: 0px; */
					top: 0;
					width: 45%;
					/* 目录栏的高度,这里设置为60%主要是为了不挡住返回顶部和折叠按钮 */
					height: 90%;
					/* 设置边框这样和正文对比比较明显 */
					border: 2px solid #eaeaea;
					/* 开启垂直滚动条 */
					overflow-y: scroll;
					z-index: 99;
					display: none;
					background: white;
					font-size: 20px;
					/* line-height: 2em; */
			}
			
			/* 正文的样式 */
			#book_body {
					width: 100%;
					display: block;
			}
			img{
				display: block;
			}
			code,tt{
					color:#c7254e;
					background-color:#f9f2f4;
			}

			/* 返回顶部按钮样式 */
			#topButton {
					position: fixed;
					float: right;
					right: 2%;
					top: 95%;
					z-index:99;
			}

			/* 目录展开或者折叠 */
			#foldOrUnfold {
					position: fixed;
					float: left;
					right: 4%;
					top: 90%;
					z-index:99;
			}
	}
</style>
<!--侧栏目录生成代码-->
<script>
    $(document).ready(function () {
        $("h1,h2,h3,h4,h5,h6").each(function (i, item) {
            //获取标签的名字,h1,还是h2
            var tag = $(item).get(0).localName;
            //为该标签设置id属性
            $(item).attr("id", "wow" + i);
            //添加一个页内超链接,并设置class选择器
            $("#category").append('<div class="newh"><a class="new' + tag + '" href="#wow' + i + '">' + $(item).text() +
                '</a></div>');
            //为每一个标题超链接的class属性设置左边距
            $(".newh1").css("margin-left", "0em");
            $(".newh2").css("margin-left", "1em");
            $(".newh3").css("margin-left", "2em");
            $(".newh4").css("margin-left", "3em");
            $(".newh5").css("margin-left", "4em");
            $(".newh6").css("margin-left", "5em");
						$(".newh1").css("font-size", "1.5em");
						$(".newh2").css("font-size", "1.2em");
						$(".newh3").css("font-size", "1em");
						$(".newh4").css("font-size", "0.9em");
						$(".newh5").css("font-size", "0.8em");
						$(".newh1").css("font-weight", "bold");
						$(".newh2").css("font-weight", "bold");
        });
        //设置class选择器为.book-body的html内容
        $(".book-body").html($(".book-body").nextAll())
				$(".newh").on("click",function(){
					console.log($(this).children("a"));
					$(this).children("a")[0].click();
				});
    });
</script>
<script>
    // 展开或者折叠目录功能
    function showOrCloseCategory() {
        var id = document.getElementById("category");
        var write = document.getElementById("write");
				//console.log(id.style.display);
        //如果展开了
        if (id.style.display == 'block') {
            //console.log("开始展开");
            id.style.display = 'none';
						write.style.float = "";
						write.style.left = "0em";
        }
        //如果被折叠了
        else if (id.style.display == 'none') {
            //console.log("开始折叠");
            id.style.display = 'block';
						write.style.float = "right";
						write.style.left = "1em";
        }
    }
    // 返回顶部功能
    function topFunction() {
        document.body.scrollTop = 0;
        document.documentElement.scrollTop = 0;
    }
</script>
<!--返回顶部-->
<button onclick="topFunction()" id="topButton">TOP↑</button>
<button onclick="showOrCloseCategory()" id="foldOrUnfold">目录</button>

<!--文章主体部分-->
<div class="book-body" id="book_body"> </div>
<!--目录栏-->
<div class="book-summary" id="category" style="display:none"></div>
<title>pond</title>


<script src="../../autoload.js"></script>
<p><a class="resume-link" href="../index.html">返回主页</a><br/><a class="resume-link" href="../index.html">返回上一页</a></p>
</style><title>pond</title>
</head>
<body class='typora-export os-windows'><div class='typora-export-content'>
<div id='write'  class=''><h1 id='pond-asplos23'><span>Pond (ASPLOS&#39;23)</span></h1><p><span>【Title】Pond: CXL-Based Memory Pooling Systems for Cloud Platforms</span></p><p><span>【定语描述】the first memory pooling system that both meets cloud performance goals and significantly reduces DRAM cost</span></p><p>&nbsp;</p><h2 id='comments'><span>Comments</span></h2><p><strong><span>不愧是ASPLOS&#39;23杰出论文</span></strong><span>，这种文章再给我十年我都写不出来这篇文章一半的水平。感觉像是分析类论文和设计类论文完美合二为一，且仅仅在14页（包含参考文献）内就解释的比较清楚（但也正因如此，有些细节可能就一两句话，还需要进一步思考）。目前功力有限，许多地方还没太明白（比如虚拟加速器等等），这篇文章笔记会</span><strong><span>陆续迭代更新</span></strong><span>！</span></p><p><span>回到文章本身，像之前Memstrata笔记提过的一样，CXL太适合内存池化了。内存池化又非常适合云服务虚拟化场景。在未来的服务器集群或者数据中心，可以预见的是CXL会成为其中一大重要组成部分（阿里也是这么干的）。那CXL内存池就是一个新的场景，存在着许多未发现的问题和早就有的经典的问题。</span></p><p><span>没有（讨论）CXL的时候，也早就有RDMA内存池等等的概念。类似于延迟的问题也确实很早就应该有提到过。但是内存池的规模对延迟的影响，确实是我第一次在这篇文章中看到的。然后就是application对延迟的sensitive不一样，这也很显而易见。这篇文章就提供了一个非常好的量化数据。一结合，就更凸显了池规模的影响。这些看起来很直觉，但是也确实很重要。另一个大的点就是经典的内存搁浅（Memory Stranding），文章认为对这些Non-usage 的Memory，可以丢进内存池做一个zNUMA节点，完全（几乎）不会对VM产生影响，好处就是提升了利用率，那就能省钱了。相当于省了一大部分服务器内存的投入。那整个数据中心服务器越多，产生的经济效益的数量级就越大。</span></p><p><span>最后都是用了一个机器学习的模型进行预测，依然是看起来很直觉很简单，但是要确定什么样的指标、什么样的特性、什么样的标签，怎么样定义一个合理的损失，怎么样去减少缓解隐藏学习开销，都是值得深思的问题。以及多个模型如何平衡，平衡问题转化成什么样的优化问题，也是一个巧妙的地方。</span></p><p><span>例如本文Pond 旨在最大化分配到 CXL 池上的平均内存量，这由延迟不敏感性 (LI) 和未使用内存 (UM) 定义，同时保持错误预测率 (FP) 和超预测率 (OP) 低于目标虚拟机百分比 (TP)。FP和OP分别是LI和TP的函数，这里存在两个参数化的模型。两个模型的平衡通过解决一个基于给定性能降级容限 (PDM) 和达到该容限的目标虚拟机 (TP) 百分比的优化问题来实现。</span></p><p>&nbsp;</p><h2 id='相关概念'><span>相关概念</span></h2><h3 id='znuma'><span>zNUMA</span></h3><p><span>zNUMA（零核心虚拟 NUMA）是一种优化内存分配的机制，它通过创建一个没有 CPU 核心、但有内存的虚拟 NUMA 节点，来提高内存利用率并降低性能损失。</span></p><p><span>在云计算环境中，虚拟机（VM）通常运行在多个物理核心上。当 VM 被分配到不同 NUMA 节点的核心时，虚拟机内的进程可能需要访问远程内存，这会导致性能下降。因此，云服务提供商通常尝试</span><strong><span>将虚拟机的内存和核心绑定在同一个 NUMA 节点</span></strong><span>上，以确保较低的内存访问延迟。</span></p><p><span>zNUMA 是一种改进的虚拟 NUMA 节点技术，它的关键特点是该 NUMA 节点没有 CPU 核心，只有内存。</span></p><p><span>zNUMA 的一个重要功能是引导操作系统远离该节点上的内存分配。具体来说，操作系统会优先选择非 zNUMA 节点的内存来进行主要工作负载的分配，因为这些节点有对应的 CPU 核心，性能更好。而 </span><strong><span>zNUMA 节点则保留用于非关键性内存分配，比如一些闲置或者非时间敏感的数据</span></strong><span>。很多虚拟机通常不会使用它们所分配的全部内存。在这种情况下，zNUMA 节点可以容纳这些未使用的内存，而不需要对实际分配的内存进行管理调整。这意味着，</span><strong><span>即使虚拟机分配了大量内存，但未使用的部分可以放置在 zNUMA 节点，不会占用性能关键的本地 NUMA 内存</span></strong><span>。</span></p><p><span>由于 zNUMA 节点上的内存不包含关键性数据，虚拟机的性能不会受到影响。即使该内存被分配到了 zNUMA 节点，操作系统的内存管理机制也会确保重要的内存访问发生在有 CPU 核心的 NUMA 节点上。</span></p><p><span>zNUMA 的使用尤其适用于云计算环境中的虚拟机，这些虚拟机常常没有充分使用它们被分配的内存。例如，Azure 的测量显示，大约 50% 的虚拟机只使用了它们分配内存的一半甚至更少。zNUMA 允许这些未使用的内存进入一个共享池，从而为其他服务器所用，而不会影响当前虚拟机的性能。</span></p><p>&nbsp;</p><h2 id='introduction'><span>Introduction</span></h2><p><span>许多企业和用户在使用公有云时，会通过虚拟机（VM）来运行他们的应用程序或工作负载。虚拟机的好处是可以获得接近于独立服务器的计算性能，而不需要用户自己去管理数据中心的硬件和基础设施。</span></p><p><span>然而，对于公有云提供商来说，这样的模式带来了一个挑战：</span><strong><span>他们要在不深入了解用户虚拟机内部运行内容的前提下（即，虚拟机对云服务商来说是不透明的），仍然需要保证高性能，同时控制硬件成本</span></strong><span>。因此，如何为这些不透明的虚拟机提供既高效又经济的计算资源，成为了云服务商需要解决的难题。</span></p><p><span>同时，由于DRAM的扩展性差且只有初步替代品可供选择，它已成为硬件成本的主要部分。例如，在Azure中，DRAM可以占服务器成本的50%，而在Meta中，DRAM占机架成本的40%。通过对Azure生产跟踪数据的分析，我们发现</span><strong><span>内存闲置是内存浪费的主要原因，也是潜在的大幅成本节省的来源</span></strong><span>。内存闲置发生在服务器的所有核心已被租用（即分配给客户的虚拟机），但未分配的内存容量仍然存在且无法租用。我们发现，随着更多核心分配给虚拟机，多达25%的DRAM会变成闲置状态。</span></p><p><span>管存在大量的内存闲置问题，在公共云中减少DRAM使用仍然具有挑战性，因为它有严格的性能要求。例如，现有的进程级内存压缩技术需要</span><strong><span>处理页错误（page fault）</span></strong><span>，这会</span><strong><span>增加微秒级的延迟</span></strong><span>，并且需要放弃静态预分配内存的方式。通过分离式内存（memory disaggregation）进行内存池化是一种有前景的方法，因为闲置的内存可以返回到解耦的内存池中，并供其他服务器使用。不幸的是，现有的池化系统同样有微秒级的访问延迟，并且需要处理页错误或对虚拟机客户系统进行修改。</span></p><p>&nbsp;</p><p><strong><span>4个Key Insights</span></strong></p><ul><li><p><span>随着池的规模增大，延迟也随之增加。 8-16个sockets的服务器分组也能够实现pooling的大部分好处。</span></p><ul><li><p><span>文中的描述是8-16个sockets（就是小规模的pool）的延迟会增加70-90ns，而机架级别的延迟会增加180ns。</span></p></li></ul></li><li><p><span>21%+的负载对pooling后的延迟增加敏感</span></p><ul><li><p><span>结合第一点就突出了small pools的必要性</span></p></li></ul></li><li><p><span>约一半的虚拟机仅使用了租用内存的一半或更少，虚拟机的 zNUMA 大小与其未使用的内存相匹配时，确实不会出现任何性能影响</span></p></li><li><p><span>这段不太像insights,反而像是说pond这个工作做了什么</span></p><ul><li><p><span>主要也是基于机器学习方法的预测，预测的target是（1）VM是否latency sensitive （2）VM未使用的内存余量</span></p></li><li><p><span>预测不准的话，pond还利用监控机制触发缓解措施</span></p></li><li><p><span>ML模型输入的可以监控遥测，不会显著增加开销</span></p></li></ul></li></ul><p>&nbsp;</p><p><strong><span>提到的Contributions</span></strong></p><ul><li><p><span>首次公开对大型公共云提供商内存滞留和未触及内存的特征描述。</span></p></li><li><p><span>首次分析了不同 CXL 内存池大小的有效性和延迟。</span></p></li><li><p><span>Pond，首个基于 CXL 的全栈内存池，适用于云部署，且具备实际可行性和性能。</span></p></li><li><p><span>用于数据中心规模的延迟和资源管理的准确预测模型。这些模型可以实现 1-5% 的可配置性能降低。</span></p></li><li><p><span>广泛的评估验证了 Pond 的设计，包括 zNUMA 的性能以及我们预测模型在生产环境中的表现。我们的分析显示，通过使用跨越 16 个插槽的 Pond 池，我们可以将 DRAM 需求减少 7%，这对应于大型云提供商节省数亿美元的成本*</span></p></li></ul><p>&nbsp;</p><h2 id='background'><span>Background</span></h2><h3 id='hypervisor-memory-management'><span>Hypervisor Memory Management</span></h3><p><span>在公共云中，计算资源通常以虚拟机（VM）的形式提供。虚拟化技术使得单台物理服务器可以运行多个虚拟机，每个虚拟机看起来都像是独立的计算机。</span><strong><span>Hypervisor</span></strong><span>负责管理虚拟机的资源，包括内存。为了优化虚拟机的性能并减少管理开销，</span><strong><span>Hypervisor</span></strong><span>尽量减少对内存的直接管理。它们通常依赖虚拟化加速器来提高输入/输出（I/O）性能。这些加速器可以帮助减少虚拟化带来的性能损失，使虚拟机的 I/O 操作更高效。</span><strong><span>直接 I/O 设备分配 (DDA)</span></strong><span> 和 </span><strong><span>单根 I/O 虚拟化 (SR-IOV)</span></strong><span> 是两种常见的虚拟化加速技术。这些技术帮助提升虚拟机的网络和存储性能，减少虚拟化层的中间处理。</span></p><ul><li><p><strong><span>DDA</span></strong><span> 允许虚拟机直接访问物理 I/O 设备，从而减少虚拟化层的开销。</span></p></li><li><p><strong><span>SR-IOV</span></strong><span> 使得网络设备能够被多个虚拟机共享，同时保持高性能。</span></p></li></ul><p><span>在 AWS 和 Azure 等云服务平台上，加速网络是默认启用的。这意味着它们在虚拟机和网络之间的通信中使用这些加速器，以提高数据传输速度和降低延迟。为了</span><strong><span>使虚拟化加速技术有效</span></strong><span>，虚拟机监控器需要</span><strong><span>静态地预分配或“固定”虚拟机的整个地址空间</span></strong><span>。这意味着</span><strong><span>在虚拟机运行之前，就已经为它分配了固定的内存空间</span></strong><span>。这种做法可以</span><strong><span>确保虚拟机的内存访问不会受到动态分配带来的性能影响</span></strong><span>。</span></p><p>&nbsp;</p><h3 id='memory-stranding'><span>Memory Stranding</span></h3><p><strong><span>内存闲置</span></strong><span>是在云计算环境中常见的问题，涉及资源分配和优化。</span></p><p><span>云服务的性能调优是一个多维装箱(背包)问题，在有限的资源中合理地安排物品，使得资源的利用最大化或浪费最小化。云服务提供商需要解决一个多维的装箱问题，即如何在有限的服务器资源上高效地安排虚拟机。在设计和配置服务器时，很难准确预测未来虚拟机的资源需求。因此，</span><strong><span>匹配服务器资源与未来虚拟机的实际需求</span></strong><span>是一项挑战。当实际到达的虚拟机对内存（DRAM）和 CPU 核心的需求与服务器提供的资源不匹配时，就会使得资源的高效利用变得更加困难。</span></p><p><span>内存闲置的例子就是在一个服务器中，虽然所有 CPU 核心已经被租用，但仍然有未被使用的内存。这种情况下的内存就是“闲置”的，因为虽然它在理论上可以租给客户，但由于所有的 CPU 核心已经被占用，实际租用内存变得不可行。</span></p><p>&nbsp;</p><h3 id='resource-stranding'><span>Resource Stranding</span></h3><p><span>有多种技术可以减少内存资源滞留。例如，超额订阅核心（oversubscribing cores）可以使更多的内存得以出租。然而，因为性能原因，超额订阅仅适用于部分虚拟机。文章说在 Azure 上测量包括启用超额订阅的集群，但仍然显示出显著的Memory Stranding。</span></p><p>&nbsp;</p><h3 id='what-does-pond-do-'><span>What does pond do ?</span></h3><p><span>Pond针对的方法是将一部分内存解耦成一个可以被多个主机访问的池。这打破了服务器的固定硬件配置。通过动态地将内存重新分配给不同的主机，我们可以将内存资源转移到需要它们的地方，而不是依赖于每台单独的服务器在所有情况下都以悲观的方式进行配置。因此，我们可以将服务器的配置接近于平均的 DRAM 到核心的比例，并通过内存池来处理偏差。</span></p><p>&nbsp;</p><h3 id='cxl-pooling'><span>CXL Pooling</span></h3><p><span>通过 CXL 的池化。CXL 包含多个协议，包括</span><code>load/store</code><span>内存语义（</span><code>CXL.mem</code><span>）和 I/O 语义（</span><code>CXL.io</code><span>）。</span></p><ul><li><p><code>CXL.mem</code><span> 将设备内存映射到系统地址空间。</span></p><ul><li><p><span>当系统的最后一级缓存（LLC）缺失某个缓存行时，会生成对 CXL 端口的请求，该端口将带来缺失的数据行。写回操作也会通过 CXL 进行数据写入。这些操作不涉及页面错误处理或直接内存访问（DMA），从而减少了开销。</span></p></li><li><p><span>类似地，LLC 的写回操作会转换成 CXL 数据写入。以上操作</span><strong><span>都不涉及页面错误或直接内存访问（DMA）</span></strong><span>。</span><strong><span>CXL 内存使用虚拟化监控程序的页表和内存管理单元（MMU）进行虚拟化，因此与虚拟化加速兼容。</span></strong></p></li></ul></li><li><p><code>CXL.io</code><span> 协议便于设备发现和配置。CXL 1.1 针对直接连接的设备，CXL 2.0 增加了基于交换机的池化功能，而 CXL 3.0 标准化了无交换机的池化和更高的带宽。</span></p></li></ul><p><code>CXL.mem</code><span> 使用 PCIe 的电气接口，并具有定制的链路和事务层，以实现低延迟。使用 PCIe 5.0 时，一个双向 ×8-CXL 端口的带宽在典型的 2:1 读写比下与 DDR5-4800 通道相匹配。</span><strong><span>CXL 请求的延迟主要由 CXL 端口决定。Intel 测量的 CXL 端口往返延迟为 25ns</span></strong><span> ，结合预期的控制器侧延迟，</span><strong><span>导致在基本拓扑中 CXL 读取的端到端开销为 70ns</span></strong><span>，相较于 NUMA 本地 DRAM 读取。虽然基于 FPGA 的原型报告了更高的延迟，但 70ns 的延迟开销符合行业对基于 ASIC 的内存控制器的期望。</span></p><p><img src=".\pond_p1.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h2 id='memory-stranding--workload-sensitive-to-memory-latency'><span>Memory Stranding &amp; Workload Sensitive to Memory Latency</span></h2><h3 id='memory-stranding-2'><span>Memory Stranding</span></h3><p><img src=".\pond_p2.png" referrerpolicy="no-referrer"></p><ul><li><p><span>根据这个图，一个有意义的insight是，随着CPU利用率的提高，闲置的内存增多。</span><strong><span>内存闲置是高度利用节点的产生的负作用，而高度利用的节点与高度利用的集群相关联。</span></strong></p></li></ul><blockquote><p><span>例如，一些快照中的虚拟机组合偏向于</span><strong><span>计算密集型</span></strong><span>虚拟机类型，这些类型</span><strong><span>不需要大量的 DRAM</span></strong><span>。这可能会导致在低利用率下也出现高闲置情况。在第 95 百分位，闲置率在高利用率期间达到 25%。个别离群点甚至达到 30% 的闲置率。</span></p></blockquote><p>&nbsp;</p><h3 id='numa-spinning'><span>NUMA Spinning</span></h3><p><span>NUMA（非统一内存访问）架构在多处理器系统中，每个处理器节点都与一定数量的内存紧密相连。为了优化性能，虚拟机监控程序（hypervisor）通常会尽量将虚拟机的计算核心和内存分配到同一个 NUMA 节点上，减少跨节点访问的延迟。</span></p><p><span>然而，在某些情况下，特别是</span><strong><span>在系统资源紧张或虚拟机配置不均衡</span></strong><span>时，虚拟机的核心可能会集中在一个 NUMA 节点，而内存却被分配到另一个节点上，这种现象称为 NUMA 跨越。尽管这种跨越会增加访问延迟，但在 Azure 上，这种情况比较少见：约 2-3% 的虚拟机出现 NUMA 跨越，而跨越的内存页比例不到 1%。</span></p><p><span>这种跨越情况的出现可能是由于资源分配的限制或系统负载不均匀。在实践中，虚拟机监控程序会尽量避免这种情况，以确保性能最优化，但在资源紧张时，NUMA 跨越是难以完全避免的。</span></p><p>&nbsp;</p><h3 id='saving-from-pooling'><span>Saving from pooling</span></h3><p><img src=".\pond_p3.png" referrerpolicy="no-referrer"></p><p><span>这里提到的</span><code>Pool Size</code><span>指的就是</span><code>CPU Sockets</code><span>的数量</span></p><p><span>根据上面这张图，可以得到这样的信息：不管是哪个比例（分配给每个VM的pool memory比例），在Pool Size变得比较大后，能够节省的DRAM非常有限。蓝色的线从32个Sockets到64个Sockets节省的DRAM直观上感觉就1%左右。</span></p><p>&nbsp;</p><ul><li><p><span>本文作者声称观察到在生产环境中，</span><code>95th</code><span>的内存遗留率为 3%-27%，一些异常值达到 36%。</span></p></li></ul><ul><li><p><span>几乎所有虚拟机都适合放在一个 NUMA 节点中。</span></p></li><li><p><strong><span>在 16-32 个socket之间进行内存池化可以减少集群内存需求 10%。这表明，内存池化可以显著降低成本，但这假设了很高比例的 DRAM 可以分配到内存池中</span></strong><span>。</span><strong><span>当实现跨 NUMA 节点的 DRAM 池时，提供商必须仔细缓解潜在的性能影响</span></strong><span>。</span></p></li></ul><p>&nbsp;</p><h3 id='vm-memory-usage'><span>VM Memory Usage</span></h3><p><span>据本文作者描述，在Azure中，所有集群中都有大量虚拟机存在未被使用的内存。总体而言，第 50 百分位的未使用内存为 50%。</span></p><ul><li><p><span>虚拟机内存使用情况差异很大。</span></p></li><li><p><span>在未使用内存最少的集群中，仍有超过 50% 的虚拟机存在超过 20% 的未使用内存。因此，有大量未使用的内存可以被去聚合而不会造成性能损失。</span></p></li><li><p><span>面临的挑战是：（1）预测虚拟机可能拥有的未使用内存量，以及（2）将虚拟机的访问限制在本地内存上。</span></p><ul><li><p><span>Pond要解决的就是这2个问题</span></p></li></ul></li></ul><p>&nbsp;</p><h3 id='workload-sensitivity-to-memory-latency'><span>Workload Sensitivity to Memory Latency</span></h3><p><img src=".\pond_p4.png" referrerpolicy="no-referrer"></p><p><img src=".\pond_p5.png" referrerpolicy="no-referrer"></p><p><span>这个工作使用两种模拟 CXL 访问延迟（182%，222%）的场景下对 158 个工作负载进行评估，并与Local NUMA性能进行评估。</span></p><ul><li><p><span>在内存延迟增加 182% 的情况下</span></p><ul><li><p><span>26% 的 158 个工作负载在 CXL 下的slowdown少于 1%</span></p></li><li><p><span>另外 17% 的工作负载看到的slowdown不到 5%</span></p></li><li><p><span>有 21% 的工作负载面临超过 25% 的slowdown</span></p></li></ul></li></ul><p><span>一般来说，我们发现更高的延迟会放大低延迟下的效果</span></p><ul><li><p><span>在 182% 延迟下表现良好的工作负载在 222% 延迟下也趋于表现良好；而在 182% 延迟下受到严重影响的工作负载在 222% 延迟下则受到更大的影响。</span></p></li></ul><p><span>所以一个很大的Motivation就是 </span><strong><span>缓解对那些对延迟敏感的工作负载的 CXL 延迟影响</span></strong><span>。</span></p><p><strong><span>如果能够有效识别敏感工作负载，内存池化解决方案可能会很有效</span></strong></p><p><span>也就是说延迟不敏感的VM需要的memory可以都直接给CXL内存池里的。</span></p><p>&nbsp;</p><h2 id='pond-design'><span>Pond Design</span></h2><p><span>整个Pond的设计目标主要包括下面四个</span></p><ul><li><p><span>性能可与 NUMA 本地 DRAM 相媲美（低成本、高性能）</span></p><ul><li><p><span>为了量化这个问题，文章定义了performance degradation margin (PDM，性能降级边际)，以表示相对于完全在 NUMA 本地 DRAM 上运行工作负载的允许的性能下降。Pond 旨在实现一个可配置的 PDM，例如 1%，适用于一个可配置的尾部百分比 (TP) 的虚拟机，例如 98%。</span></p></li><li><p><span>为了实现这种高性能，Pond 使用一个小而快速的 CXL 内存池 </span></p></li><li><p><span>由于 Pond 的内存节省来自池化而非超额订阅，Pond 必须在其系统软件层中</span><strong><span>最小化池的碎片化和浪费</span></strong></p></li></ul></li><li><p><span>与虚拟化加速器兼容 （硬件兼容性）</span></p><ul><li><p><span>Pond 在虚拟机启动时预分配本地和池内存。Pond 在其分配、性能监控和缓解管道（mitigation pipeline）中决定这些分配。该管道使用新颖的预测模型来实现 PDM。</span></p></li></ul></li><li><p><span>与不透明的虚拟机和客户操作系统/应用程序兼容 （软件兼容性）</span></p><ul><li><p><span>使用轻量级的硬件计数器遥测来克服虚拟机的不透明性</span></p></li></ul></li><li><p><span>主机资源开销低 </span></p><ul><li><p><span>使用轻量级的硬件计数器遥测来克服虚拟机的主机开销 </span></p></li></ul></li></ul><p>&nbsp;</p><h3 id='hardware-layer'><span>Hardware Layer</span></h3><p><strong><span>这一段太硬了，说实话不是很想看，总之就是说8-16 socket的延迟比较低</span></strong></p><p><span>Pond Pool中的Host拥有独立的缓存一致性域，并运行各自的 hypervisor。Pond 使用一种所有权模型，其中pool memory在主机之间显式移动。一个新的外部内存控制器 (EMC) ASIC 使用多个 DDR5 通道通过一组运行在 PCIe 5 速度下的 CXL 端口来实现池内存。</span></p><p><img src=".\fond_p6.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p><strong><span>EMC 内存管理。</span></strong><span> EMC 提供多个 CXL 端口，并在每个主机上呈现为单个逻辑内存设备 。在 CXL 3.0  中，这种配置被标准化为多头设备 (MHD) 。EMC 通过一个主机管理的设备内存 (HDM) 解码器在每个端口上</span><strong><span>暴露其全部容量</span></strong><span>（例如，提供给主机）。主机对每个 EMC 的地址范围进行编程，但</span><strong><span>最初将其视为离线</span></strong><span>。Pond 动态分配内存，</span><strong><span>粒度为 1GB 的内存切片</span></strong><span>。</span><strong><span>每个切片在任何给定时间只分配给一个主机，主机会显式地收到有关更改的通知</span></strong><span>。</span><strong><span>跟踪 1024 个切片（1TB）和 64 个主机（6 位）需要 768B 的 EMC 状态</span></strong><span>。EMC 通过检查每个内存访问的权限，即</span><strong><span>请求者和缓存行切片的所有者是否匹配，来实现动态切片分配</span></strong><span>。不允许的访问会导致致命的内存错误。</span></p><p><span>EMC 提供多个 ×8-CXL 端口，这些端口通过片上网络 (NOC) 与 DDR5 内存控制器 (MC) 通信。这些 MC 必须具备与服务器级内存控制器相同的可靠性、可用性和可维护性能力，包括内存错误纠正、管理和隔离。</span></p><p><strong><span>Pond 的 EMC 的一个关键设计参数是池的大小，这定义了能够使用池内存的 CPU Sockets数量</span></strong><span>。我 EMC 的 IO、(De)Serializer 和 MC 需求类似于 AMD Genoa 的 397𝑚𝑚2 IO-die (IOD) 。如上图显示，16 插槽 Pond 的 EMC 需求与 IOD 的需求相匹配，而一个小型 8 sockets Pond 则与 IOD 的一半相匹配。因此，最多可以有 16 个sockets直接连接到一个 EMC。池大小为 32-64 的情况下，将结合 CXL switch与 Pond 的多头 EMC。最佳设计点在于平衡较大pool size的潜在节省与较大 EMC 和switch的额外成本。</span></p><p><img src=".\pond_v7.png" referrerpolicy="no-referrer"></p><p><strong><span>EMC 延迟。</span></strong><span> 尽管延迟受传播延迟的影响，但主要由 CXL 端口延迟以及任何使用的 CXL 重定时器和 CXL Switch决定。</span></p><p><span>在数据中心条件下，信号完整性模拟表明 CXL 在超过 500mm 的距离上可能需要</span><strong><span>重定时器</span></strong><span>。Switch由于端口/仲裁/NOC 造成至少 70ns 的延迟，估计超过 100ns 。</span></p><p>&nbsp;</p><p><img src=".\pond_p8.png" referrerpolicy="no-referrer"></p><p><strong><span>Pond 在 8 和 16 插槽池下将延迟降低了 1/3，仅比 NUMA 本地 DRAM 增加了 70-90ns</span></strong></p><p>&nbsp;</p><h3 id='system-software-layer'><span>System Software Layer</span></h3><p><span>软件层面有几个组件构成，详细信息请参见论文</span></p><p><strong><span>Pool Memory Ownership</span></strong></p><p><span>池管理涉及将 Pond 的内存切片分配给主机，并为池回收这些内存。这包括</span></p><ul><li><p><span>实现pool memory分配的控制路径</span></p></li><li><p><span>防止pool memory碎片化。</span></p></li></ul><p>&nbsp;</p><p><strong><span>Failure management</span></strong><span> 故障管理</span></p><p><span>Hosts在cacheline粒度上interleave accorss-socket local memory。尽管hosts可能连接到多个EMC，但不会在EMC之间交错内存。这最小化了EMC的影响范围，并便于内存热插拔。EMC故障仅影响在该EMC上拥有内存的虚拟机，而其他EMC上的虚拟机则正常运行。</span><strong><span>CPU/Host故障是隔离的，相关的池内存将重新分配给其他主机。池管理器故障会阻止重新分配池内存，但不会影响数据路径</span></strong><span>。</span></p><p>&nbsp;</p><p><strong><span>Exposing pool memory to VMs</span></strong></p><p><span>将池内存暴露给虚拟机。使用NUMA本地内存和池内存的虚拟机</span><strong><span>将池内存视为zNUMA节点</span></strong><span>。虚拟机监控器通过添加一个内存块（node_memblk）来创建zNUMA节点，但在SLIT/SRAT表中的node_cpuid中没有相应的条目。</span><strong><span>Guest OS优先从本地NUMA节点分配内存，然后才会使用zNUMA</span></strong><span>。因此，如果zNUMA的大小设置为未使用的内存量，它将永远不会被使用。下面是一个Linux VM，其中包含NUMA距离矩阵（numa_slit）中的正确延迟。Guest操作系统提供了NUMA感知的内存管理</span></p><p><img src=".\pond_p10.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>&nbsp;</p><p><strong><span>Reconfiguration of memory allocation</span></strong></p><p><span>为了保持与虚拟加速器兼容，本地和池内存映射在虚拟机生命周期内通常保持</span><strong><span>静态</span></strong><span>。但有两个Exception:</span></p><ul><li><p><span>虚拟机的实时迁移</span></p></li><li><p><span>发生内存故障时重新映射页面时</span></p></li></ul><p><span>虚拟机监控器会</span><strong><span>暂时禁用虚拟化加速</span></strong><span>，虚拟机将回退到较慢的I/O路径。这两种情况都是快速且短暂的，</span><strong><span>通常在虚拟机的生命周期内只发生一次</span></strong><span>。</span></p><p><span>Pond实现了第三种变体，允许Pond对次优内存分配进行一次性修正。</span></p><ul><li><p><strong><span>如果主机有可用的本地内存，Pond会禁用加速器，将虚拟机的所有内存复制到本地内存中，然后再次启用加速器。</span></strong></p><ul><li><p><span>对于每GB分配给虚拟机的池内存，这大约需要50毫秒</span></p></li></ul></li></ul><p>&nbsp;</p><p><strong><span>Telemetry for opaque VMs</span></strong></p><p><span>不透明虚拟机的</span><strong><span>遥测</span></strong><span>。Pond 需要两种类型的虚拟机遥测数据。</span></p><ul><li><p><span>使用核心性能测量单元（PMU）来</span><strong><span>收集与内存性能相关的硬件计数器</span></strong><span>。</span></p><ul><li><p><span>具体而言，pond使用顶层分析法TMA。TMA 描述了核心流水线sockets的使用情况。例如，使用“内存绑定”指标，它定义为由于内存加载和存储导致的流水线停顿。图12列出了这些指标。虽然 TMA 是为 Intel 开发的，但其相关部分也适用于 AMD 和 ARM。</span></p></li></ul></li><li><p><span>使用虚拟机监控器的遥测功能来跟踪虚拟机的未使用页面</span></p><ul><li><p><span>利用现有的计数器来跟踪客户机已提交的内存，该计数器通常会高估实际使用的内存量。该计数器适用于98%的Azure虚拟机</span></p></li></ul></li></ul><p><img src=".\pond_p12.png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><p>&nbsp;</p><h3 id='distributed-control-plane-layer'><span>Distributed Control Plane Layer</span></h3><p><img src=".\pond_p11.png" referrerpolicy="no-referrer"></p><p><span>这层的两个主要任务</span></p><ul><li><p><span>在虚拟机调度过程中进行内存分配预测</span></p></li><li><p><span> QoS监控和问题解决</span></p></li></ul><p>&nbsp;</p><p><span>对于（1）</span><code>Predictions and VM scheduling</code><span> 这个任务</span></p><p><span>Pond 使用基于机器学习的预测模型来决定为虚拟机分配多少池内存。当虚拟机请求到达后（A1），调度器会向分布式机器学习服务系统查询（A2），以预测该虚拟机需要分配多少本地内存。然后，调度器将目标主机和相关的池内存需求告知池管理器（A3）。池管理器通过配置总线触发EMC和主机的内存上线工作流程（A4）。内存上线速度足够快，不会阻碍虚拟机的启动时间。调度器通知虚拟机监控器在与上线内存量匹配的zNUMA节点上启动虚拟机。内存下线速度较慢，无法在虚拟机启动的关键路径上进行。Pond 通过始终保持一部分未分配的池内存缓冲区来解决这个问题。当虚拟机终止时，主机异步释放相关的内存片段，以补充该缓冲区。</span></p><p>&nbsp;</p><p><span>对于（2）</span><code>QoS monitoring</code><span> 这个任务</span></p><p><span>Pond 通过其 QoS 监控器</span><strong><span>持续检查所有正在运行虚拟机的性能</span></strong><span>。监控器会查询虚拟机监控器和硬件性能计数器（B1），并使用延迟敏感度的机器学习模型来判断虚拟机的性能影响是否超出 PDM。如果超出，监控器会请求其</span><strong><span>缓解管理器（B2）通过虚拟机监控器触发内存重新配置（B3）。重新配置后，虚拟机将只使用本地内存。</span></strong></p><p>&nbsp;</p><p>&nbsp;</p><h3 id='prediction-models'><span>Prediction Models</span></h3><p><img src=".\pond_p13.png" referrerpolicy="no-referrer"></p><p><strong><code>Predictions for VM scheduling (A)</code></strong></p><p><span>在调度时，首先检查</span><strong><span>是否可以将工作负载历史与请求的虚拟机相关联</span></strong><span>。这是通过检查是否有之前</span><strong><span>具有与请求虚拟机相同元数据的虚拟机</span></strong><span>来实现的，例如客户ID、虚拟机类型和位置。这基于这样一个观察：</span><strong><span>来自同一客户的虚拟机往往表现出类似的行为</span></strong><span>。如果有之前的工作负载历史，就会</span><strong><span>预测该虚拟机是否可能对内存延迟不敏感</span></strong><span>，即在仅使用池内存时，其性能将保持在 PDM 之内。对延迟不敏感的虚拟机将完全分配在池 DRAM 上。</span></p><blockquote><p><span>单独再写一遍： </span><strong><span>来自同一客户的虚拟机往往表现出类似的行为</span></strong></p></blockquote><p><span>根据上述图，简单总结一下：</span></p><ul><li><p><span>有无历史记录，无历史记录就直接认为latency-sensitive</span></p></li><li><p><span>non-latency-sensitive 直接把pool memory丢给它</span></p></li><li><p><span>latency-sensitive就得再看看Untouched Memory （后面都写成UM）</span></p></li><li><p><span>UM=0，就只分配local DRAM (有一个问题：</span><code>Local DRAM满了怎么办 ？ 多个VM可以用一个Local DRAM对吧？</code><span>)</span></p></li><li><p><span>UM&gt;0 以GB向下取整，按百分比分配pool memory &amp; zNUMA节点，剩下就是local DRAM</span></p></li><li><p><span>UM要是（预测）过大，就调用QoS缓解器缓解一下</span></p></li></ul><p><strong><span>重要的是，Pond 始终保持虚拟机的内存在虚拟机监控器的页表中映射。这意味着即使预测不准确，性能也不会急剧下降。</span></strong></p><p>&nbsp;</p><p><strong><code>QoS monitoring (B)</code></strong></p><p><span>对于 zNUMA 虚拟机，Pond 监控在调度期间是否高估了未使用内存的数量。对于使用内存池支持的虚拟机以及未使用内存少于预测量的 zNUMA 虚拟机，pond使用</span><strong><span>敏感度模型</span></strong><span>来确定虚拟机工作负载</span><strong><span>是否遭受了过多的性能损失</span></strong><span>。如果没有，QoS 监控器将启动实时虚拟机迁移，将其重新配置为完全分配到本地 DRAM 上。</span></p><p>&nbsp;</p><h3 id='model-details'><span>Model details</span></h3><p><img src=".\pond_p14.png" referrerpolicy="no-referrer"></p><p><span>Pond 的两个机器学习预测模型利用 Pond 系统软件层中可用于不透明虚拟机的</span><strong><span>遥测数据</span></strong><span>。</span></p><p><span>(</span><strong><span>Telemetry for opaque VMs</span></strong><span> 那一节的图) 展示了</span><strong><span>延迟不敏感性模型的特征、标签以及训练过程</span></strong><span>。该模型使用</span><strong><span>监督学习</span></strong><span> ，以核心性能监控单元（PMU）指标作为特征，并</span><strong><span>以内存池相对于 NUMA 本地内存的slowdown作为标签</span></strong><span>。Pond 通过</span><strong><span>离线测试</span></strong><span>运行和</span><strong><span>内部工作负载的 A/B 测试</span></strong><span>获取slowdown样本，并使用这些性能数据重新训练模型。这些特征-标签对</span><strong><span>每天</span></strong><span>都会用来重新训练模型。由于核心 PMU 负载较轻，Pond 在虚拟机运行时持续测量核心 PMU 指标。这使得 QoS 监控器能够</span><strong><span>快速反应</span></strong><span>，并</span><strong><span>保留那些对延迟敏感的虚拟机的历史记录</span></strong><span>。上图展示了未使用内存模型的输入和训练过程。该模型使用监督学习，以</span><strong><span>虚拟机的元数据</span></strong><span>作为特征，以</span><strong><span>每个虚拟机生命周期中的最小未使用内存量作为标签</span></strong><span>。其</span><strong><span>最重要的特征是过去一周内某客户虚拟机记录的未使用内存的百分位数范围（如 80%–99%）</span></strong></p><p>&nbsp;</p><h3 id='parameterization-of-prediction-models'><span>Parameterization of prediction models</span></h3><p><span>Pond 的延迟不敏感性模型</span><strong><span>通过参数化</span></strong><span>来确保</span><strong><span>错误预测率 (FP)</span></strong><span> 保持在</span><strong><span>目标值以下</span></strong><span>，即模型错误地将工作负载标记为延迟不敏感，而实际上这些工作负载对内存延迟是敏感的。这个参数</span><strong><span>强制了一个权衡</span></strong><span>，因为被标记为</span><strong><span>延迟不敏感 (LI)</span></strong><span> 的工作负载百分比</span><strong><span>是 FP 的函数</span></strong><span>。</span></p><blockquote><p><span>例如，</span><strong><span>0.1% 的错误预测率可能会导致模型将 5% 的工作负载标记为延迟不敏感</span></strong><span>。</span></p></blockquote><blockquote><p><span>这个数值应该会变化，那怎样变化呢？0.1%FP导致 LI+5%。那0.2% FP呢 ？ 这一定是线性的吗？</span></p></blockquote><p><span>同样，Pond 的未使用内存模型也</span><strong><span>通过参数化</span></strong><span>来确保</span><strong><span>超预测率 (Overprediction, OP) 保持在目标值以下</span></strong><span>，即模型预测的工作负载使用的内存比实际多，从而会使用 zNUMA 节点上的内存页。该参数强制了一个权衡，因为</span><strong><span>未使用内存 (UM) 的百分比是 OP 的函数</span></strong><span>。</span></p><blockquote><p><span>例如，0.1% 的超预测率可能会导致模型预测 3% 的未使用内存。</span></p></blockquote><p><span>由于存在两个模型及其各自的参数，Pond 需要决定如何在两个模型之间</span><strong><span>平衡错误预测率 (FP) 和超预测率 (OP)</span></strong><span>。这种平衡通过</span><strong><span>解决一个基于给定性能降级容限 (PDM) 和达到该容限的目标虚拟机 (TP) 百分比的优化问题</span></strong><span>来实现。</span></p><p><span>具体来说，</span><strong><span>Pond 旨在最大化分配到 CXL 池上的平均内存量，这由延迟不敏感性 (LI) 和未使用内存 (UM) 定义，同时保持错误预测率 (FP) 和超预测率 (OP) 低于目标虚拟机百分比 (TP)</span></strong><span>。</span></p><p><strong><span>TP 本质上定义了 QoS Moniter需要参与并启动内存重配置的频率</span></strong><span>。除了 PDM 和 TP 之外，Pond 没有其他参数，因为它会自动解决来自如下公式的优化问题。模型依赖其各自框架的默认超参数 </span></p><p><img src=".\pond_p(f).png" referrerpolicy="no-referrer"></p><p>&nbsp;</p><h2 id='findings'><span>Findings</span></h2><p><span>有几个非常有意义，有几个其实就是单纯的实验结果，也算不太上是Findings，只能算是Results。</span></p><p><span>这怎么不是一种写作技巧呢？ （doge</span></p><h3 id='finding-1'><span>Finding #1</span></h3><ul><li><p><span>zNUMA 节点在将内存访问限制在本地 vNUMA 节点上非常有效。只有一小部分访问会到达 zNUMA 节点。</span></p></li></ul><p><span>作者怀疑这部分原因是由于Guest OS内存管理器的元数据被明确分配在每个 vNUMA 节点上。作者发现，视频工作负载发送的内存访问中少于 0.25% 会到达 zNUMA 节点。同样，另外三个工作负载发送到 zNUMA 节点的内存访问占比为 0.06% 到 0.38%。</span><strong><span>本地 vNUMA 节点内的访问是分散的</span></strong><span>。</span></p><blockquote><p><span>由于 zNUMA 上的内存访问占比微乎其微，我们预计在正确预测未使用内存的情况下，性能影响也会微不足道。</span></p></blockquote><p>&nbsp;</p><h3 id='finding-2'><span>Finding #2</span></h3><ul><li><p><span>在对未使用内存的</span><strong><span>正确</span></strong><span>预测下，工作负载的减速分布与全部使用本地内存时相似</span></p></li></ul><blockquote><p><span>这个性能结果是预期的，因为 zNUMA 节点很少被访问 (§6.2)。因此，我们的评估可以在对未使用内存的正确预测下假设没有性能影响 (§6.5)。</span></p></blockquote><p>&nbsp;</p><h3 id='finding-3'><span>Finding #3</span></h3><ul><li><p><span>对于未使用内存的</span><strong><span>过度预测</span></strong><span>（以及相应地，</span><strong><span>局部 vNUMA 节点的规模不足</span></strong><span>），</span><strong><span>工作负载会溢出到 zNUMA</span></strong><span>。</span><strong><span>许多工作负载会立即受到slowdown的影响</span></strong><span>。如果更多的工作负载内存溢出到 zNUMA，减速情况将进一步加剧。有些工作负载的减速幅度高达 30-35%，当 20-75% 的工作负载内存溢出时，如果完全分配在池内存上，则减速幅度可达 50%。我们使用访问位扫描来验证这些工作负载确实在积极访问其整个工作集。</span></p></li></ul><blockquote><p><span>将固定比例的池内存分配给虚拟机会导致显著的性能减速。减少这种影响只有两个策略：1）识别哪些工作负载会出现减速；2）在池内存上分配未使用内存。Pond 同时采用这两种策略。</span></p></blockquote><p>&nbsp;</p><h3 id='finding-4'><span>Finding #4</span></h3><ul><li><p><span>虽然 DRAM 限制与slowdown相关，但我们发现一些例子，</span><strong><span>即使在只有小百分比的 DRAM 限制情况下，仍然会出现较高的slowdown</span></strong><span>。例如，多个工作负载在仅有 2% 的 DRAM 限制时就超过了 20% 的slowdown。</span></p></li></ul><blockquote><p><span>这表明预测工作负载是否超过 PDM 的困难性。启发式方法和预测器都会产生统计误差。</span></p></blockquote><p>&nbsp;</p><h3 id='finding-5'><span>Finding #5</span></h3><ul><li><p><span>我们发现“DRAM Bound”明显优于“Memory Bound”。我们的随机森林模型的表现略优于“DRAM Bound”。</span></p></li></ul><p><img src=".\pond_p17.png" referrerpolicy="no-referrer"></p><h3 id='finding-6'><span>Finding #6</span></h3><ul><li><p><span>GBM 模型的准确性比静态策略高出 5 倍。例如，当将 20% 的内存标记为未使用时，GBM 仅过度预测 2.5% 的虚拟机，而静态策略则过度预测 12%。</span></p></li></ul><p>&nbsp;</p><h3 id='finding-7'><span>Finding #7</span></h3><ul><li><p><span>模型的生产版本表现与模拟模型相似。分布变化导致随时间出现一些波动。</span></p></li></ul><blockquote><p><span>准确预测未使用内存是可行的，并且是一个现实的假设。</span></p></blockquote><p>&nbsp;</p><h3 id='finding-8'><span>Finding #8</span></h3><ul><li><p><span>Pond 的组合模型通过找到各个模型的最佳组合而优于其单独模型。</span></p></li></ul><p>&nbsp;</p><h3 id='finding-9'><span>Finding #9</span></h3><ul><li><p><span>在池大小为 16 个sockets时，Pond 在延迟增加 182% 和 222% 的情况下，分别减少了 9% 和 7% 的整体 DRAM 需求。静态策略减少了 3% 的 DRAM。当 PDM 在 1% 到 10% 之间变化，TP 在 90% 到 99.9% 之间变化时，我们发现这三个系统的相对节省效果 qualitatively 相似</span></p></li></ul><p>&nbsp;</p><h3 id='finding-10'><span>Finding #10</span></h3><ul><li><p><span>在整个仿真过程中，Pond 的池内存离线速度在 99.99% 和 99.999% 的虚拟机启动情况下分别保持在 1GB/s 和 10GB/s 以下</span></p></li></ul><p>&nbsp;</p></div></div>
</body>
</html>